{"meta":{"title":"程序员疯子的博客-Code is Art, Code is Poetry!","subtitle":null,"description":null,"author":"Fengzijk","url":"http://91fz.org"},"pages":[{"title":"","date":"2017-06-25T19:30:06.357Z","updated":"2017-06-25T19:30:06.357Z","comments":true,"path":"404.html","permalink":"http://91fz.org/404.html","excerpt":"","text":""},{"title":"","date":"2017-06-26T09:51:20.862Z","updated":"2017-06-26T09:51:20.862Z","comments":false,"path":"about/index.html","permalink":"http://91fz.org/about/index.html","excerpt":"","text":"Aboat me技能 语言: java PHP python kotlin 中间件 ： Zero-ice dubbo zookeeper mycat cat thrift gorpcsoringCloud jenkins RokectMq 框架：struts2 spring mybatis soringCloud Elasticsearch vue 技术关键词：SOA 服务治理 微服务 JVM 多线程 微信开发 开源 自我介绍 -2009年开始做discuz个人站，以及视频站点，2013年参加工作，至今做JAVA开发相关工作 联系方式 Email：guozhifengvip@163.com QQ号：543439318 微博：Apache疯子 知乎：fengzijk 关于本站几经周折，从当初的VPS上找到了当时的WordPress站点，数据丢了之后，经过同事的建议开始做静态站点。写博客只是用来总结一些自己的笔记 分享一些走过的坑。无关其他… 2016 年用 jekyll 2017 年开始用 hexo"},{"title":"archives","date":"2014-06-25T17:43:35.000Z","updated":"2017-06-25T19:51:15.566Z","comments":true,"path":"archives/index.html","permalink":"http://91fz.org/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-25T17:43:01.000Z","updated":"2017-06-25T17:43:01.967Z","comments":true,"path":"categories/index.html","permalink":"http://91fz.org/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-06-25T17:46:32.394Z","comments":false,"path":"tags/index.html","permalink":"http://91fz.org/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"谈谈服务治理与微服务","slug":"fuwu01","date":"2017-06-26T16:00:00.000Z","updated":"2017-06-27T08:55:47.027Z","comments":true,"path":"2017/06/27/fuwu01/","link":"","permalink":"http://91fz.org/2017/06/27/fuwu01/","excerpt":"","text":"谈谈服务治理与微服务近期都在大谈微服务，本人也在做相关的工作已经两年左右了，做了一个微服务的分享，整理了这篇文章，有问题可以在下面留言，可以和大家一起讨论。 先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。 互联网架构演变单体体架构在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。 如下图： 单体式应用的优点明显：现有IDE都是集成开发环境，非常适合单体式应用，开发、编译、调试一站式搞定。一个应用包含所有功能，容易测试和部署。运行在一个物理节点，环境单一，运行稳定，故障恢复简单。 单体式应用的缺点也明显：业务边界模糊，模块职责不清晰，当系统逐渐变大，代码依赖复杂，难以维护。所有人同时在一个工程上开发，容易发生代码修改冲突，依赖复杂导致项目协调困难，并且局部修改影响不可知，需要全覆盖测试，需要重新部署，难以支持大团队并行开发。当系统很大时，编译和部署耗时。应用水平扩展难，一方面状态在应用内部管理，无法透明路由；另一方面，不同模块对资源需求差异大，当业务量增大时，一视同仁地为所有模块增加机器导致硬件浪费。 MVC架构但随着浏览器的出现便产生了web应用，web应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css+js+html技术来处理，而后端可以用Java、PHP等语言，这就产生了前后端分离。对于web系统，一体架构难以满足前后端分离的开发需求，因而便产生了MVC架构。为什么我把Mvc但那处处呢，因为他也有划时代的意义，其实从大方向讲MVC架构也是单体架构的一种 MVC架构如下图： MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。 但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了多应用架构。 多应用架构多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。如下图： 多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。 分布式架构对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。 因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。 在分布式应用架构中，应用相互独立，每个应用代码独立开发，独立部署，应用通过有限的API接口互相关联。API接口属于应用一部分，一般和表示层处于同一层次，两者共享业务逻辑层，API和表示层采用同样的web端技术，通讯协议一般使用HTTP，数据格式是JSON，应用集成方式比较简化。 分布式架构首先对系统按照业务进行垂直切分，把系统切分为不同应用，针对资源需求特点（比如CPU/IO/存储密集型），通过加强硬件配置满足不同应用的需求，避免一刀切方式带来的资源浪费。 技术上，API采用标准的HTTP/JSON进行通讯，调用双方实现难度都不大，但是API一般是“裸奔”的，在系统层面，调用依赖关系不透明，调用可靠性缺乏保障，因此只适用应用之间依赖链路少，调用量不大的系统，即应用之间耦合确实够松的系统。 SOA架构有人说SOA就是分布式，其实这个界限有点模糊，不过相比较普通API方式，SOA架构更进一步： 每个service都是浓缩的精华，聚焦某方面核心业务，同时以复用的方式供整个系统共享。 服务作为独立的应用，独立部署，接口清晰，很容易做自动化测试和部署。 服务是无状态的，很容易做水平扩展；通过容器虚拟化技术，实现故障隔离和资源高效利用，业务量大的时候，加机器即可。 基于SOA的系统可以根据服务运行情况，灵活调控服务资源，包括服务上下架、服务升降级等，使系统真正具备可运营的能力。 当然天下没有免费的午餐，SOA也带来了额外复杂性和弊端： 系统依赖复杂，给开发/测试/部署带来一系列挑战。 端到端的调用链路长，可靠性降低，依赖网络状况、服务框架及具体service的质量。 分布式数据一致性和分布式事务支持困难，一般通过最终一致性简化解决。端到端的测试和排障复杂，SOA对运维提出更高要求。例子如下： SOA的特点 可从企业外部访问 随时可用 粗粒度的服务接口分级 松散耦合 可重用的服务 服务接口设计管理 标准化的服务接口 支持各种消息模式 精确定义的服务契约说起SOA 我第一想到的是企业服务总线（ESB） SOA的好处那么SOA有哪些好处呢？ 架构上系统更加清晰 核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险 开发管理方便 单独团队维护、工作分明，职责清晰 业务复用、代码复用 非常容易拓展 SOA实现方式 如果要实现SOA的话，最常用的方式就是利用RPC框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC远程服务调用。类似于RPC方案有很多，比如： Java RMI WebService Hessian Thrift … … 服务化面临的挑战 上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。 服务越来越多，配置管理复杂 服务间依赖关系复杂 服务之间的负载均衡 服务的拓展 服务监控 服务降级 服务鉴权 服务上线与下线 服务文档 … …有时间我会专门写一篇关于RPC的文章我们接着往下说，有了服务 就需要治理跟维护 下面我们讲一讲服务治理 服务治理上面提到了服务化，其实要想服务化，服务治理是关键。那么有没有好的服务治理方案呢？答案是有的，而且还很多，比如： ICE dubbo springcloud 魔毯 等等下面我们简单说说服务治理所需要的 集中的注册中心和存储库，以查找和发布与服务相关的构件和元数据。 查找正确的授权服务。 避免重复工作。 促进重用。 确定服务在 SOA 生命周期中的当前状态。 为服务订阅者提供可见性。 确定相关服务和更改某个服务所造成的影响。 传达对服务所做的更改。 用于联系和强制应用于某个服务的策略的机制。策略通过使用治理框架来定义。 具有生命周期感知性的可自定义系统，该系统在生命周期中发生阶段更改时触发验证，以便能够自动化逐个阶段的治理验证。 在理想的情况下，注册中心应该针对SOA运行时进行优化，以便能够在运行时期间，使用存储在注册中心的元数据来通过动态路由充实内容。详细的各个中间件的原理以及怎么解决服务治理的我会专门写文章继续往下说 从去年微服务突然火了起来，咱们看看微服务 微服务 在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。 微服务有两个核心： 微：服务的粒度要细，即服务要细化到API(要做到这一点很不容易，比如服务的切分) 服务：提供好服务，要让用户感到好用 上面两个核心总结起来，可以用下面这幅图表示： 从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。 我们可以看到，有了微服务之后，服务对用户来说变得特别简单。不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。 说到这里，大家就应该大体知道该怎么做微服务了 其实“云”是最关键的。微服务的关键是服务网关，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。 微服务的特点 服务需要再细化成API（服务接口——&gt;服务API） 每个服务由一组API组成 以API形式对外提供统一格式的服务 使用者无需任何配置，直接调用（http） 完整的API文档 API服务安全可靠稳定 总结：大概是15年8月接触SOA吧以上就是我的粗浅理解，下一篇我会介绍服务治理的几个框架","categories":[],"tags":[]},{"title":"Kotlin初探 集成springMvc","slug":"kotlindemo","date":"2017-05-31T16:00:00.000Z","updated":"2017-06-27T06:50:37.089Z","comments":true,"path":"2017/06/01/kotlindemo/","link":"","permalink":"http://91fz.org/2017/06/01/kotlindemo/","excerpt":"","text":"自从Google I/O 大会上宣布 Kotlin 成为 Android 开发的官方语言，Kotlin 就吸引了很多人的目光，反正在家休息、研究了下，整理成这篇博客来简单介绍下Kotlin。 Kotlin的起源Kotlin是一个基于JVM的新的编程语言，由JetBrains开发。JetBrains，作为目前广受欢迎的Java IDE IntelliJ的提供商，在Apache许可下已经开源其Kotlin编程语言。与Java相比，Kotlin的语法更简洁、更具表达性，而且提供了更多的特性，比如，高阶函数、操作符重载、字符串模板。它与Java高度可互操作，而且还可以同时用在一个项目中。 Kotlin与Java语言上的比较 函数式的：Kotlin是基于面向对象的语言。使用了很多函数式编程的概念，比如，使用lambda表达式来更方便地解决问题。其中一个很棒的特性就是Collections的处理方式。但是java 在8中也支持函数式编程，lamda表达式这些当然也不在话下了。 可以扩展函数：意味着我们可以扩展类的更多的特性，甚至我们没有权限去访问这个类中的代码。例如，以下代码可以更简单的使用Toast 12345678fun Activity.toast(message: CharSequence, duration: Int = oast.LENGTH_SHORT)&#123; Toast.makeText(this, message, duration).show()&#125; Activity：表示函数的接收者，也就是函数扩展的对象 . ：扩展函数修饰符 toast：扩展函数的名称 (...)：扩展函数的参数，可以为null 高度互操作性的：可以继续使用所Java写的代码和库，因为两个语言之间的互操作性是完美的。甚至可以在项目中使用Kotlin和Java混合编程 如上图，我们可以轻松的使用 Intellij IDEA 自带的代码转换把Java代码转换为Kotlin代码Kotlin 的文件是 .kt 结尾，向 .kt 文件中粘贴 Java 代码时都能自动转化为 Kotlin 代码，这点让我想到了当初搞ZeroC-ice的ICE的中间语言slice，不过slice能可以根据你的需求翻译成各种常见的语言，不过数据类型转换却比较难（这不是本次的重点）。 更加易表现：Kotlin最重要的优点之一。开发相同功能你可以少写很多的代码。以下这个类是一个很常见的Java类，但是使用Kotlin可以节省很多代码量。 1234567891011121314151617181920212223242526272829public class Student &#123; private String name;//姓名 private int age;//年龄 private String hobby;//爱好 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 使用Kotlin达到同样的效果只需要一行代码 1class Student(var name: String, var age: Int, var hobby: String) 更加安全：Kotlin是空安全的，就是说在编译时期就处理了各种null的情况，避免了执行时异常。如果一个对象可以是null，则我们需要明确地指定它，然后在使之前检查是否是null。可以节约很多调试空指针的时间并解决相应的bug。 123456789//普通的 String 类型的变量不能为空var str: String =&quot;abc&quot;str = null //编译错误-------------------------//允许为空，我们必须把它声明为可空的变量：var b: String? = &quot;abc&quot;b = null 使用Kotlin整合springMvc写了一个 web项目的demo 首先安装Kotlin的插件首先创建一个 Kotlin 项目，然后添加 Maven 组件 完成后项目结构如下pom文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;kotlin&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;source&gt;src/main/java&lt;/source&gt; &lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;phase&gt;process-test-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt;&lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;kotlin.version&gt;1.1.2-4&lt;/kotlin.version&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.7.3&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson作为controller层的json转换器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring.xml 文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.timothy.web&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; springmvc.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.timothy.web.controller&quot; /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven&gt; &lt;!-- json转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;text/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 接下来做一个简单的 Controller 示例KotlinController的代码如下所示：12345678910111213141516171819202122package com.timothy.web.controllerimport com.timothy.web.pojo.Personimport com.timothy.web.service.KotlinServiceimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.web.bind.annotation.RequestMappingimport org.springframework.web.bind.annotation.RestController/** * Created by timothy on 2017/6/1. */@RestControllerclass KotlinController &#123; @Autowired private var kotlinService: KotlinService? = null @Autowired private var person: Person? = null @RequestMapping(&quot;/kotlin&quot;) fun home() = mapOf(&quot;kotlin&quot; to kotlinService?.kotlin(), &quot;map&quot; to kotlinService?.map(), &quot;person&quot; to person)&#125; KotlinService代码： 12345678910111213package com.timothy.web.serviceimport org.springframework.stereotype.Service/** * Created by timothy on 2017/6/1. */@Serviceclass KotlinService &#123; fun kotlin() = &quot;kotlin&quot; fun map() = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3)&#125; bean代码 123456789package com.timothy.web.pojoimport org.springframework.stereotype.Component/** * Created by timothy on 2017/6/1. */@Componentdata internal class Person(var name: String? = &quot;timothy&quot;, var id: Int? = 1) 效果如下： 总结：可以看出，Kotlin 代替 Java 开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的 的经典框架。同时，Kotlin 的一些新特性也让代码的简洁性和易读性有了一定程度的提高","categories":[],"tags":[]},{"title":"阿里云部署 Web 环境（LAMP）","slug":"阿里云部署lamp","date":"2016-10-18T16:00:00.000Z","updated":"2017-06-26T09:26:51.418Z","comments":true,"path":"2016/10/19/阿里云部署lamp/","link":"","permalink":"http://91fz.org/2016/10/19/阿里云部署lamp/","excerpt":"","text":"阿里云部署 Web 环境（LAMP）这里给大家介绍如何使用阿里云镜像，一键部署 Web 环境，包括安装 Nginx、MySQL、phpwind 和 phpMyAdmin。软件包中包含的软件及版本如下：nginx：1.4.4apache：2.2.29、2.4.10mysql：5.1.73、5.5.40、5.6.21php：5.2.17、5.3.29、5.4.23、5.5.7php 扩展：memcache、Zend Engine/OPcachejdk：1.7.0tomcat：7.0.54ftp：（yum/apt-get 安装）phpwind：8.7 GBKphpmyadmin：4.1.8 说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。 准备工作 部署之前，请确保： 您的实例可以连接公网。 已经安装用于连接 Linux 实例的工具，如 Xshell 和 Xftp。本文将以这两个工具为例介绍操作步骤。 注意：阿里云 Linux 一键安装 Web 环境安装包暂不支持自动挂载 I/O 优化的数据盘。 操作步骤在浏览器中打开阿里云的云市场。搜索 阿里云linux一键安装web环境，然后购买该软件。登录云服务器管理控制台。打开 产品与服务&gt; 云市场。单击 已购买的服务。在 阿里云Linux一键安装Web环境的右侧，单击 管理。点击 下载地址，一键下载安装包。解压缩安装包。文件夹名称为sh-1.5.5。说明：这是写文档时参考的文件夹名称，您下载的版本可能与此不同。确保您安装了连接 Linux 实例的工具，如 Xshell 和 Xftp。打开 Xshell，设置登录实例所需的信息。设置连接名称。协议选择 SSH。输入主机公网 IP 地址。端口号填 22。然后单击 确定 保存。单击左侧导航中的 连接 &gt; 用户身份验证，验证方法选择 Password，然后输入用户名root 和登录密码。 单击 Xshell 工具栏的 Xftp 图标 （新建文件传输），或使用快捷键 CTRL + ALT + F 打开Xftp。然后通过 Xftp 上传一键安装包文件，直接按住左侧的本地安装文件夹，拖放到右侧 Linux 实例的目录下。回到 Xshell 的链接界面，依次键入以下安装命令。 123chmod -R 777 sh-1.5.5cd sh-1.5.5./install.sh 安装完成后执行 cat account.log 命令，可以查看 account.log 文件，数据库密码在里面. 根据需要选择 1 (nginx) 或者 2 (apache)。如直接回车，或输入错误字符，则默认选择 nginx。在示例中，此处选择 2。注意：如果要使用 Java 环境（安装 tomcat+JDK），必须选择 nginx 服务器。依次选择要安装的 nginx 或 Apache 版本、PHP 版本、MySQL 版本。nginx 和 PHP 建议选择最新的版本。注意：MySQL 建议选择 5.5.40，不要选择最新版本，否则可能无法正常使用。 输入 y 开始安装。一般需要半个小时左右安装完毕。看到下面这个界面，就表示安装顺利完成了 检查安装结果，输入下面的命令。1netstat -tunpl -端口与服务信息如下：-9000：PHP进程服务。如果安装的是Apache，则没有此端口。-3306：MySQL服务-80：HTTPD 或者 nginx 服务-21：FTP服务输入以下命令，查看默认的 FTP 和 MySQL 的账号信息：1cat account.log 输入该命令后，系统会在屏幕上显示 FTP 和 MySQL 的用户名和密码。其中 FTP 的用户名是 www，MySQL 的用户名是 root。 修改 FTP 密码：用 root 登录，执行下列命令，然后输入您的 FTP 新密码: 修改 MySQL 密码。注意： -p 和旧密码之间没有空格；而 password 和新密码之间有空格 1mysqladmin -uroot -p旧密码 password 新密码 输入命令 cat /alidata/website-info.log，查看刚才安装软件的版本信息。至此所有配置结束。 安装 phpwind 和 phpMyAdmin。可以通过访问一键安装包默认安装的 phpwind 进行安装。直接在浏览器中输入您的域名或者 IP。如果是第一次访问 phpwind，系统会自动跳转到安装页面。单击 接受 进行安装。 在创建数据页面，单击 下一步。 选择数据库类型为 MySQL，数据库用户名和密码填写 account.log 中的用户名和刚修改过的密码。然后设置数据库名称、管理员账号和密码等信息。单击 下一步。系统会自动安装。 接下来访问 phpMyAdmin。在浏览器中输入域名，或者 IP/phpmyadmin 路径 （如 http://127.0.0.1/phpmyadmin ），访问 phpMyAdmin。输入 MySQL 用户名和密码，然后单击 执行，即可登录。 从 phpMyAdmin 即可操作 MySQL。可以创建博客使用的数据库。输入数据库名称，然后排序规则选择 utf8_general_ci，单击 创建。 恭喜您！您已经成功部署了 Web 环境，可以开始制作和发布自己的站点了。 卸载一键安装包如果需要卸载一键安装包，执行下列命令： 123chmod 777 -R sh-1.5.5cd sh-1.5.5./uninstall.sh","categories":[],"tags":[]},{"title":"QQ实用技术（从以前的博客拿过来的2011年手机写的 纯粹怀旧）","slug":"QQ技术","date":"2015-08-10T16:00:00.000Z","updated":"2017-06-26T10:33:43.993Z","comments":true,"path":"2015/08/11/QQ技术/","link":"","permalink":"http://91fz.org/2015/08/11/QQ技术/","excerpt":"","text":"QQ实用技术（从以前的博客拿过来的2011年手机写的 纯粹怀旧）首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！盗取QQ的方式有 (1)远程木马盗号 (2)强制破解 (3)键盘纪录 (4)钓鱼网站，-(5)恶意申诉 第一种方法《远程木马盗号》远程木马盗号的软件有“盗Q黑侠，广外幽灵，QQ机器人，QQ远程攻击器，QQ流感，阿拉QQ大盗，QQ explorer QQ密码使者等， 它们的使用都差不多。我用的是QQ邮箱收信，去邮箱设置里把软件地址设为白名单，例如:gzf@qinan.me，然后填写收件地址(这个区别前面的是要盗的号的邮箱)。还有发件地址(就是你收密码和发邮件的邮箱). 第二步，生成木马(这个是软件自带) 第三步 相当重要，重命名该木马，取一个吸引人的名字，例如:美女裸照，然后修改后缀(这个可以百度搜软件)，木马一般都是可运行程序，后缀是exe，要骗警惕的人不容易，那我们可以把他换成图片后缀(jpg，gif，等)音乐后缀(mp3，wma等)视频后缀(mp4，Avi，flv，mrvb，等) 第四步，发邮件，一般把木马藏在附件里面，然后等那人运行木马后，我们可以在邮箱里查看密码和IP， 第二种方法是《本地破解》这种成功率低的伤不起，之所以我用过，因为比较简单，就是用QQ暴力破解，下载词典，然后输入QQ号码，先猜可能的密码，例如:我确定某人的密码是纯数字，就选数字词典，然后就等待破解，如果有字母就在词典里加字母就可以了。 第三种《键盘纪录》这种在网吧比较好用，下载键盘纪录软件(一定要能躲过还原精灵的那种，如果家庭电脑就没必要)注意点有二，第一要安装正确，二记住键盘输入纪录所在文件夹，这个是最简单的，可以直接查看。但是，如果用软件盘输入它就无能为力了！嘿嘿！ 第四种就是《恶意申诉》这个成功油水肥，可以改密保问题，是我常用的一种，申诉大家都会，不多说，注意点有，你必须有2个以上的小号，加的目标号码时间越长成功率越高，三不知道的不要乱猜，据我的经验，一般申请的都是网页免费申请，不多说，具体操作，自己把握，第五钓鱼网站，这个从去年开始比较流行，现在中毒转发减肥和色 情聊天的都是这么中毒的，这个需要熟悉网站制作，要求比较高，比较麻烦，就不多说！ 下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单1，拒绝好奇心不要接收陌生人的离线文件，熟人不知道什么东西的情况下就也不乱接，包括邮件里面的附件。（尤其多人转发的那种邮件） 2，IP代理再QQ登录框下面的高级设置里(找不到你的iP地址木马无法攻击)键盘纪录防范，只要软键盘输入就行了， 3，暴力破解防范密码越复杂越好，你数字中加一个标点符号，破解难度就得翻几倍。 4，恶意申诉只有一个办法，绑钉自己身份证(前提是别人不知道你的身份证号码和姓名) 5，鱼肉，记住一句话就可以，天上不掉馅饼，掉陷井，不要去玩色 站，和黑基，开挂等。 6看好友隐身和ip地址的软件qq彩虹 赛博qq 从初三玩 qq有6，7年了 以上就是我对各位童鞋的各种悲剧的一些建议！（以前用手机写的 还记得是Mtk的，纯粹为了怀旧，以上软件用不了）","categories":[],"tags":[]},{"title":"安装ZeroC-ICE","slug":"安装Zero-ICE","date":"2015-08-09T16:00:00.000Z","updated":"2017-06-26T09:52:15.652Z","comments":true,"path":"2015/08/10/安装Zero-ICE/","link":"","permalink":"http://91fz.org/2015/08/10/安装Zero-ICE/","excerpt":"","text":"ubuntu 安装1234567891011121314151617181920212223242526272829303132wget https://zeroc.com/download/GPG-KEY-zeroc-release sudo apt-key add GPG-KEY-zeroc-release sudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot; sudo apt-get update sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devwget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devUbuntu 15.04wget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu15.04 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devUbuntu 14.04wget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu14.04 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devGPG KeyThe Linux binary distributions are signed with our release key.Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997Sample ProgramsA collection of sample programs are available on GitHub. You can download them by running the following command:git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.gitRefer to GitHub&apos;s help page for more information. centos 安装123456789101112131415161718192021222324 Install on Red Hat Enterprise LinuxDocumentation: Using the Linux Binary DistributionsIncludes: Runtime and SDK for Ice for C++, Java, PHP, and all Ice services.Red Hat Enterprise Linux 7Prerequisite: You may need to enable the RHEL 7 Server Optional repository for several dependencies.cd /etc/yum.repos.dsudo wget https://zeroc.com/download/rpm/zeroc-ice-el7.reposudo yum install ice-all-runtime ice-all-develRed Hat Enterprise Linux 6cd /etc/yum.repos.dsudo wget https://zeroc.com/download/rpm/zeroc-ice-el6.reposudo yum install ice-all-runtime ice-all-develGPG KeyThe Linux binary distributions are signed with our release key.Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997Sample ProgramsA collection of sample programs are available on GitHub. You can download them by running the following command:git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.gitRefer to GitHub&apos;s help page for more information. ** 下一篇介绍用法","categories":[],"tags":[]},{"title":"让国产山寨手机死机黑屏之imy","slug":"imy","date":"2011-11-14T16:00:00.000Z","updated":"2017-06-26T06:15:01.841Z","comments":true,"path":"2011/11/15/imy/","link":"","permalink":"http://91fz.org/2011/11/15/imy/","excerpt":"","text":"让国产山寨手机死机黑屏之imy IMY铃声是一段铃声代码文件，具有占有空间小、容易编辑等特点。中国移动规定其为通用彩信文件格式之一,可以用短信进行收发（当然不花流量咯！）。IMY标准非常灵活，音域跨了9个8度，24种不同音长；还可以加入振动、屏幕背光及来电灯亮灭的效果，给人以更加美妙神奇的音乐体验。 怎样看你的手机是否支持IMY铃声？ 短信编辑界面，选项——插入对象——我的铃声/预设铃声。（IMY铃声文件在短信中会以音符的图标显示。） 若能进行上述操作，则恭喜你，你的手机支持IMY;若“我的铃声”为空白，则你的手机闪存（人们习惯上将其错叫成“手机内存”）里的“audio”文件夹里没有IMY铃声。) imy可传播手机病毒吗？ 2008年11月以来，很多人收到了一些“黑屏短信”、“死机短信”、“狂振、狂闪短信”，这些短信是怎么做到的呢？又是不是病毒呢？ 了解了IMY的本质，就不难回答上面的问题（请看上文加粗的文字）。这也正是“山寨机”容易中招的原因。 那些短信中包含有一些恶作剧的IMY铃声文件。以黑屏短信为例，这个IMY铃声文件不含声音代码，而只含有关闭背光、来电灯以及振动的命令（下面将会进一步详解），让人误认为是死机。笔者亲自试过，这个文件只会让手机黑屏73秒，并非真死，并且对手机无害。 IMY铃声调用的命令仅仅是声音指令、振动开启及关闭指令、屏幕背光和来电灯亮灭指令。所以并非病毒。虽不是病毒，但手机狂振、狂闪却应该是对手机有伤害的。 那么，如何删除带有这种恶作剧IMY铃声文件的短信呢？ ——调成静音模式，然后删除。原因是静音模式时，IMY铃声就不会播放，其中的恶作剧就不会得逞。呵呵~ 还是强烈倡议大家“和平使用”IMY铃声。过犹不及嘛，恶作剧也应有个度。 IMY铃声恶作剧例子 黑屏： 1234 BEGIN:IMELODY BEAT:1200 MELODY:(ledoffbackoffvibeoffr5ledoffbackoffvibeoffr5@600) END:IMELODY 狂震： 12345678 BEGIN:IMELODY VERSION:1.2 FORMAT:CLASS1.0 BEAT:100 MELODY:(ledoffledonbackoffbackonvibeon@300) END:IMELODY 振铃：123456 BEGIN:IMELODY VERSION:1.2 FORMAT:CLASS1.0 BEAT:200 MELODY:(ledoffbackoffvibeonr5vibeoffledonbackonr5@200) END:IMELODY IMY铃声代码详解 其实IMY铃声文件本无罪，所以大家不要被恶作剧吓到。 下面通过《生日快乐歌》的代码，来详细了解一下IMY代码格式。（两排#号间为要存储为.imy文件中的内容；引号及其中间内容为代码解释，实际代码中没有；“MELODY旋律字符串”中的空格也是为了大家看的更明白而加上的） *注意：代码一律用英文半角字符.12345678910 BEGIN:IMELODY VERSION:1.2 “版本号” FORMAT:CLASS1.0 “格式编号。取值CLASS1.0或CLASS2.0，前者居多” NAME:HAPPY BIRTHDAY “铃声名。可缺省” COMPOSER:MTK(13) “演奏乐器。可缺省” BEAT:165 “节奏。取值从25到900bpm（拍/分钟），越大节奏越快，缺省值120” STYLE:S0 “风格。取值为S0；S1；S2；缺省值S0” VOLUME:V10 “音量。取值V0到V15。V0为静音，缺省值V7” MELODY:(*3a2 V+ a2 #f2 d2 #c2 *3b1 g2 #f2 d2 V- e2 vibeon ledon backoff d1 vibeoff ledoff backon @2) “旋律字符串” END:IMELODY 12345678910111213141516171819202122“风格STYLE”中 S0：普通。每音符间有暂停，音符与暂停时间比为20:1 S1：持续。每音符间无暂停 S2：断奏。音符与暂停时间比为1:1“旋律字符串MELODY”中的特效命令 “vibeon”、“vibeoff” 分别为振动开启，停止命令； “ledoff”、“ledon” 分别为来电灯关闭、开启命令； “backoff”、“backon” 分别为屏幕背光关闭、开启命令； &quot;(&quot;+&lt;melody&gt;+&quot;@n)&quot; 为重复特效,n取值0到无穷（0为无限重复）“旋律字符串MELODY”中的音符格式 &lt;音阶&gt;&lt;升降调&gt;&lt;具体唱名&gt;&lt;音长&gt;&lt;延时符&gt; &lt;音阶&gt;：取值 “*0”、“*2”、… “*8”；(a=55Hz) | (a=110Hz) | … | (a=14080 Hz) 缺省&quot;*4&quot;，代表标准音（小字一组a音为880Hz）。 &lt;升降调&gt;：“#”代表升半音，d、g、a、c、f前可加“#”； “&amp;”代表降半音，d、g、a、b、e前可加“&amp;”。 &lt;具体唱名&gt;：c、d、e、f、g、a、b。 &lt;音长&gt;：数值&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot;，分别为全音符、半音符、1/4音符...1/32音符。 &lt;延时符&gt;：“.” | “:”| “;” ;延时符，1.5倍、1.75倍与2/3倍。“旋律字符串MELODY”中的休止符 r0，r1，r2，r3，r4，r5；停顿时长分别为全音符、半音符、1/4音符...1/32音符 。 其后同样可加延时符，如“r3.”。“旋律字符串MELODY”中音量控制 V+，V-。 怎样获得imy铃声文件？ 可以DIY。网上有一些制作imy铃声的软件，可以用他们来DIY也可以用一些软件来将其他格式的音乐转换成imy格式。还可以在网上找一些代码的文本，复制到记事本里，把文件后缀”.txt”改成”.imy”，保存到手机闪存的“audio”文件夹里即可。 OK，现在就用浪漫十足的IMY铃声来扮炫你的生活吧！！！","categories":[],"tags":[]}]}