{"meta":{"title":"程序员疯子的博客-Code is Art, Code is Poetry!","subtitle":null,"description":null,"author":"Fengzijk","url":"http://91fz.org"},"pages":[{"title":"","date":"2017-06-25T19:30:06.357Z","updated":"2017-06-25T19:30:06.357Z","comments":true,"path":"404.html","permalink":"http://91fz.org/404.html","excerpt":"","text":""},{"title":"","date":"2017-06-26T09:51:20.862Z","updated":"2017-06-26T09:51:20.862Z","comments":false,"path":"about/index.html","permalink":"http://91fz.org/about/index.html","excerpt":"","text":"Aboat me技能 语言: java PHP python kotlin 中间件 ： Zero-ice dubbo zookeeper mycat cat thrift gorpcsoringCloud jenkins RokectMq 框架：struts2 spring mybatis soringCloud Elasticsearch vue 技术关键词：SOA 服务治理 微服务 JVM 多线程 微信开发 开源 自我介绍 -2009年开始做discuz个人站，以及视频站点，2013年参加工作，至今做JAVA开发相关工作 联系方式 Email：guozhifengvip@163.com QQ号：543439318 微博：Apache疯子 知乎：fengzijk 关于本站几经周折，从当初的VPS上找到了当时的WordPress站点，数据丢了之后，经过同事的建议开始做静态站点。写博客只是用来总结一些自己的笔记 分享一些走过的坑。无关其他… 2016 年用 jekyll 2017 年开始用 hexo"},{"title":"分类","date":"2015-12-22T04:39:04.000Z","updated":"2017-06-27T09:38:32.394Z","comments":false,"path":"categories/index.html","permalink":"http://91fz.org/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2014-06-25T17:43:35.000Z","updated":"2017-06-25T19:51:15.566Z","comments":true,"path":"archives/index.html","permalink":"http://91fz.org/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2017-06-25T17:46:32.394Z","comments":false,"path":"tags/index.html","permalink":"http://91fz.org/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"谈谈服务治理与微服务","slug":"fuwu01","date":"2017-06-26T16:00:00.000Z","updated":"2017-06-27T10:47:34.565Z","comments":true,"path":"2017/06/27/fuwu01/","link":"","permalink":"http://91fz.org/2017/06/27/fuwu01/","excerpt":"","text":"谈谈服务治理与微服务近期都在大谈微服务，本人也在做相关的工作已经两年左右了，做了一个微服务的分享，整理了这篇文章，有问题可以在下面留言，可以和大家一起讨论。 先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。 互联网架构演变单体体架构在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。 如下图： 单体式应用的优点明显：现有IDE都是集成开发环境，非常适合单体式应用，开发、编译、调试一站式搞定。一个应用包含所有功能，容易测试和部署。运行在一个物理节点，环境单一，运行稳定，故障恢复简单。 单体式应用的缺点也明显：业务边界模糊，模块职责不清晰，当系统逐渐变大，代码依赖复杂，难以维护。所有人同时在一个工程上开发，容易发生代码修改冲突，依赖复杂导致项目协调困难，并且局部修改影响不可知，需要全覆盖测试，需要重新部署，难以支持大团队并行开发。当系统很大时，编译和部署耗时。应用水平扩展难，一方面状态在应用内部管理，无法透明路由；另一方面，不同模块对资源需求差异大，当业务量增大时，一视同仁地为所有模块增加机器导致硬件浪费。 MVC架构但随着浏览器的出现便产生了web应用，web应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css+js+html技术来处理，而后端可以用Java、PHP等语言，这就产生了前后端分离。对于web系统，一体架构难以满足前后端分离的开发需求，因而便产生了MVC架构。为什么我把Mvc但那处处呢，因为他也有划时代的意义，其实从大方向讲MVC架构也是单体架构的一种 MVC架构如下图： MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。 但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了多应用架构。 多应用架构多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。如下图： 多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。 分布式架构对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。 因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。 在分布式应用架构中，应用相互独立，每个应用代码独立开发，独立部署，应用通过有限的API接口互相关联。API接口属于应用一部分，一般和表示层处于同一层次，两者共享业务逻辑层，API和表示层采用同样的web端技术，通讯协议一般使用HTTP，数据格式是JSON，应用集成方式比较简化。 分布式架构首先对系统按照业务进行垂直切分，把系统切分为不同应用，针对资源需求特点（比如CPU/IO/存储密集型），通过加强硬件配置满足不同应用的需求，避免一刀切方式带来的资源浪费。 技术上，API采用标准的HTTP/JSON进行通讯，调用双方实现难度都不大，但是API一般是“裸奔”的，在系统层面，调用依赖关系不透明，调用可靠性缺乏保障，因此只适用应用之间依赖链路少，调用量不大的系统，即应用之间耦合确实够松的系统。 SOA架构有人说SOA就是分布式，其实这个界限有点模糊，不过相比较普通API方式，SOA架构更进一步： 每个service都是浓缩的精华，聚焦某方面核心业务，同时以复用的方式供整个系统共享。 服务作为独立的应用，独立部署，接口清晰，很容易做自动化测试和部署。 服务是无状态的，很容易做水平扩展；通过容器虚拟化技术，实现故障隔离和资源高效利用，业务量大的时候，加机器即可。 基于SOA的系统可以根据服务运行情况，灵活调控服务资源，包括服务上下架、服务升降级等，使系统真正具备可运营的能力。 当然天下没有免费的午餐，SOA也带来了额外复杂性和弊端： 系统依赖复杂，给开发/测试/部署带来一系列挑战。 端到端的调用链路长，可靠性降低，依赖网络状况、服务框架及具体service的质量。 分布式数据一致性和分布式事务支持困难，一般通过最终一致性简化解决。端到端的测试和排障复杂，SOA对运维提出更高要求。例子如下： SOA的特点 可从企业外部访问 随时可用 粗粒度的服务接口分级 松散耦合 可重用的服务 服务接口设计管理 标准化的服务接口 支持各种消息模式 精确定义的服务契约说起SOA 我第一想到的是企业服务总线（ESB） SOA的好处那么SOA有哪些好处呢？ 架构上系统更加清晰 核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险 开发管理方便 单独团队维护、工作分明，职责清晰 业务复用、代码复用 非常容易拓展 SOA实现方式 如果要实现SOA的话，最常用的方式就是利用RPC框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC远程服务调用。类似于RPC方案有很多，比如： Java RMI WebService Hessian Thrift … … 服务化面临的挑战上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。 服务越来越多，配置管理复杂 服务间依赖关系复杂 服务之间的负载均衡 服务的拓展 服务监控 服务降级 服务鉴权 服务上线与下线 服务文档 … …有时间我专门有写一篇关于RPC的文章我们接着往下说，有了服务 就需要治理跟维护 下面我们讲一讲服务治理 服务治理上面提到了服务化，其实要想服务化，服务治理是关键。那么有没有好的服务治理方案呢？答案是有的，而且还很多，比如： ICE dubbo springcloud 魔毯 等等下面我们简单说说服务治理所需要的 集中的注册中心和存储库，以查找和发布与服务相关的构件和元数据。 查找正确的授权服务。 避免重复工作。 促进重用。 确定服务在 SOA 生命周期中的当前状态。 为服务订阅者提供可见性。 确定相关服务和更改某个服务所造成的影响。 传达对服务所做的更改。 用于联系和强制应用于某个服务的策略的机制。策略通过使用治理框架来定义。 具有生命周期感知性的可自定义系统，该系统在生命周期中发生阶段更改时触发验证，以便能够自动化逐个阶段的治理验证。 在理想的情况下，注册中心应该针对SOA运行时进行优化，以便能够在运行时期间，使用存储在注册中心的元数据来通过动态路由充实内容。详细的各个中间件的原理以及怎么解决服务治理的我有专门写文章继续往下说 从去年微服务突然火了起来，咱们看看微服务 微服务 在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。 微服务有两个核心： 微：服务的粒度要细，即服务要细化到API(要做到这一点很不容易，比如服务的切分) 服务：提供好服务，要让用户感到好用 上面两个核心总结起来，可以用下面这幅图表示： 从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。 我们可以看到，有了微服务之后，服务对用户来说变得特别简单。不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。 说到这里，大家就应该大体知道该怎么做微服务了 其实“云”是最关键的。微服务的关键是服务网关，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。 微服务的特点 服务需要再细化成API（服务接口——&gt;服务API） 每个服务由一组API组成 以API形式对外提供统一格式的服务 使用者无需任何配置，直接调用（http） 完整的API文档 API服务安全可靠稳定 总结：大概是15年8月接触SOA吧以上就是我的粗浅理解，下一篇我会介绍服务治理的几个框架","categories":[{"name":"微服务 SOA  服务治理","slug":"微服务-SOA-服务治理","permalink":"http://91fz.org/categories/微服务-SOA-服务治理/"}],"tags":[{"name":"微服务,SOA,服务治理","slug":"微服务-SOA-服务治理","permalink":"http://91fz.org/tags/微服务-SOA-服务治理/"}]},{"title":"Kotlin初探 集成springMvc","slug":"kotlindemo","date":"2017-05-31T16:00:00.000Z","updated":"2017-06-27T09:43:01.029Z","comments":true,"path":"2017/06/01/kotlindemo/","link":"","permalink":"http://91fz.org/2017/06/01/kotlindemo/","excerpt":"","text":"自从Google I/O 大会上宣布 Kotlin 成为 Android 开发的官方语言，Kotlin 就吸引了很多人的目光，反正在家休息、研究了下，整理成这篇博客来简单介绍下Kotlin。 Kotlin的起源Kotlin是一个基于JVM的新的编程语言，由JetBrains开发。JetBrains，作为目前广受欢迎的Java IDE IntelliJ的提供商，在Apache许可下已经开源其Kotlin编程语言。与Java相比，Kotlin的语法更简洁、更具表达性，而且提供了更多的特性，比如，高阶函数、操作符重载、字符串模板。它与Java高度可互操作，而且还可以同时用在一个项目中。 Kotlin与Java语言上的比较 函数式的：Kotlin是基于面向对象的语言。使用了很多函数式编程的概念，比如，使用lambda表达式来更方便地解决问题。其中一个很棒的特性就是Collections的处理方式。但是java 在8中也支持函数式编程，lamda表达式这些当然也不在话下了。 可以扩展函数：意味着我们可以扩展类的更多的特性，甚至我们没有权限去访问这个类中的代码。例如，以下代码可以更简单的使用Toast 12345678fun Activity.toast(message: CharSequence, duration: Int = oast.LENGTH_SHORT)&#123; Toast.makeText(this, message, duration).show()&#125; Activity：表示函数的接收者，也就是函数扩展的对象 . ：扩展函数修饰符 toast：扩展函数的名称 (...)：扩展函数的参数，可以为null 高度互操作性的：可以继续使用所Java写的代码和库，因为两个语言之间的互操作性是完美的。甚至可以在项目中使用Kotlin和Java混合编程 如上图，我们可以轻松的使用 Intellij IDEA 自带的代码转换把Java代码转换为Kotlin代码Kotlin 的文件是 .kt 结尾，向 .kt 文件中粘贴 Java 代码时都能自动转化为 Kotlin 代码，这点让我想到了当初搞ZeroC-ice的ICE的中间语言slice，不过slice能可以根据你的需求翻译成各种常见的语言，不过数据类型转换却比较难（这不是本次的重点）。 更加易表现：Kotlin最重要的优点之一。开发相同功能你可以少写很多的代码。以下这个类是一个很常见的Java类，但是使用Kotlin可以节省很多代码量。 1234567891011121314151617181920212223242526272829public class Student &#123; private String name;//姓名 private int age;//年龄 private String hobby;//爱好 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 使用Kotlin达到同样的效果只需要一行代码 1class Student(var name: String, var age: Int, var hobby: String) 更加安全：Kotlin是空安全的，就是说在编译时期就处理了各种null的情况，避免了执行时异常。如果一个对象可以是null，则我们需要明确地指定它，然后在使之前检查是否是null。可以节约很多调试空指针的时间并解决相应的bug。 123456789//普通的 String 类型的变量不能为空var str: String =&quot;abc&quot;str = null //编译错误-------------------------//允许为空，我们必须把它声明为可空的变量：var b: String? = &quot;abc&quot;b = null 使用Kotlin整合springMvc写了一个 web项目的demo 首先安装Kotlin的插件首先创建一个 Kotlin 项目，然后添加 Maven 组件 完成后项目结构如下pom文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;kotlin&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;compile&lt;/id&gt; &lt;phase&gt;process-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;source&gt;src/main/java&lt;/source&gt; &lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;test-compile&lt;/id&gt; &lt;phase&gt;process-test-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt;&lt;/sourceDirs&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;kotlin.version&gt;1.1.2-4&lt;/kotlin.version&gt; &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.7.3&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson作为controller层的json转换器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt; &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt; &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring.xml 文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.timothy.web&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; springmvc.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.timothy.web.controller&quot; /&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven&gt; &lt;!-- json转换器 --&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;value&gt;text/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 接下来做一个简单的 Controller 示例KotlinController的代码如下所示：12345678910111213141516171819202122package com.timothy.web.controllerimport com.timothy.web.pojo.Personimport com.timothy.web.service.KotlinServiceimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.web.bind.annotation.RequestMappingimport org.springframework.web.bind.annotation.RestController/** * Created by timothy on 2017/6/1. */@RestControllerclass KotlinController &#123; @Autowired private var kotlinService: KotlinService? = null @Autowired private var person: Person? = null @RequestMapping(&quot;/kotlin&quot;) fun home() = mapOf(&quot;kotlin&quot; to kotlinService?.kotlin(), &quot;map&quot; to kotlinService?.map(), &quot;person&quot; to person)&#125; KotlinService代码： 12345678910111213package com.timothy.web.serviceimport org.springframework.stereotype.Service/** * Created by timothy on 2017/6/1. */@Serviceclass KotlinService &#123; fun kotlin() = &quot;kotlin&quot; fun map() = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3)&#125; bean代码 123456789package com.timothy.web.pojoimport org.springframework.stereotype.Component/** * Created by timothy on 2017/6/1. */@Componentdata internal class Person(var name: String? = &quot;timothy&quot;, var id: Int? = 1) 效果如下： 总结：可以看出，Kotlin 代替 Java 开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的 的经典框架。同时，Kotlin 的一些新特性也让代码的简洁性和易读性有了一定程度的提高","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://91fz.org/categories/Kotlin/"}],"tags":[{"name":"kotlin springmvc","slug":"kotlin-springmvc","permalink":"http://91fz.org/tags/kotlin-springmvc/"}]},{"title":"阿里云部署 Web 环境（LAMP）","slug":"阿里云部署lamp","date":"2016-10-18T16:00:00.000Z","updated":"2017-06-26T09:26:51.418Z","comments":true,"path":"2016/10/19/阿里云部署lamp/","link":"","permalink":"http://91fz.org/2016/10/19/阿里云部署lamp/","excerpt":"","text":"阿里云部署 Web 环境（LAMP）这里给大家介绍如何使用阿里云镜像，一键部署 Web 环境，包括安装 Nginx、MySQL、phpwind 和 phpMyAdmin。软件包中包含的软件及版本如下：nginx：1.4.4apache：2.2.29、2.4.10mysql：5.1.73、5.5.40、5.6.21php：5.2.17、5.3.29、5.4.23、5.5.7php 扩展：memcache、Zend Engine/OPcachejdk：1.7.0tomcat：7.0.54ftp：（yum/apt-get 安装）phpwind：8.7 GBKphpmyadmin：4.1.8 说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。 准备工作 部署之前，请确保： 您的实例可以连接公网。 已经安装用于连接 Linux 实例的工具，如 Xshell 和 Xftp。本文将以这两个工具为例介绍操作步骤。 注意：阿里云 Linux 一键安装 Web 环境安装包暂不支持自动挂载 I/O 优化的数据盘。 操作步骤在浏览器中打开阿里云的云市场。搜索 阿里云linux一键安装web环境，然后购买该软件。登录云服务器管理控制台。打开 产品与服务&gt; 云市场。单击 已购买的服务。在 阿里云Linux一键安装Web环境的右侧，单击 管理。点击 下载地址，一键下载安装包。解压缩安装包。文件夹名称为sh-1.5.5。说明：这是写文档时参考的文件夹名称，您下载的版本可能与此不同。确保您安装了连接 Linux 实例的工具，如 Xshell 和 Xftp。打开 Xshell，设置登录实例所需的信息。设置连接名称。协议选择 SSH。输入主机公网 IP 地址。端口号填 22。然后单击 确定 保存。单击左侧导航中的 连接 &gt; 用户身份验证，验证方法选择 Password，然后输入用户名root 和登录密码。 单击 Xshell 工具栏的 Xftp 图标 （新建文件传输），或使用快捷键 CTRL + ALT + F 打开Xftp。然后通过 Xftp 上传一键安装包文件，直接按住左侧的本地安装文件夹，拖放到右侧 Linux 实例的目录下。回到 Xshell 的链接界面，依次键入以下安装命令。 123chmod -R 777 sh-1.5.5cd sh-1.5.5./install.sh 安装完成后执行 cat account.log 命令，可以查看 account.log 文件，数据库密码在里面. 根据需要选择 1 (nginx) 或者 2 (apache)。如直接回车，或输入错误字符，则默认选择 nginx。在示例中，此处选择 2。注意：如果要使用 Java 环境（安装 tomcat+JDK），必须选择 nginx 服务器。依次选择要安装的 nginx 或 Apache 版本、PHP 版本、MySQL 版本。nginx 和 PHP 建议选择最新的版本。注意：MySQL 建议选择 5.5.40，不要选择最新版本，否则可能无法正常使用。 输入 y 开始安装。一般需要半个小时左右安装完毕。看到下面这个界面，就表示安装顺利完成了 检查安装结果，输入下面的命令。1netstat -tunpl -端口与服务信息如下：-9000：PHP进程服务。如果安装的是Apache，则没有此端口。-3306：MySQL服务-80：HTTPD 或者 nginx 服务-21：FTP服务输入以下命令，查看默认的 FTP 和 MySQL 的账号信息：1cat account.log 输入该命令后，系统会在屏幕上显示 FTP 和 MySQL 的用户名和密码。其中 FTP 的用户名是 www，MySQL 的用户名是 root。 修改 FTP 密码：用 root 登录，执行下列命令，然后输入您的 FTP 新密码: 修改 MySQL 密码。注意： -p 和旧密码之间没有空格；而 password 和新密码之间有空格 1mysqladmin -uroot -p旧密码 password 新密码 输入命令 cat /alidata/website-info.log，查看刚才安装软件的版本信息。至此所有配置结束。 安装 phpwind 和 phpMyAdmin。可以通过访问一键安装包默认安装的 phpwind 进行安装。直接在浏览器中输入您的域名或者 IP。如果是第一次访问 phpwind，系统会自动跳转到安装页面。单击 接受 进行安装。 在创建数据页面，单击 下一步。 选择数据库类型为 MySQL，数据库用户名和密码填写 account.log 中的用户名和刚修改过的密码。然后设置数据库名称、管理员账号和密码等信息。单击 下一步。系统会自动安装。 接下来访问 phpMyAdmin。在浏览器中输入域名，或者 IP/phpmyadmin 路径 （如 http://127.0.0.1/phpmyadmin ），访问 phpMyAdmin。输入 MySQL 用户名和密码，然后单击 执行，即可登录。 从 phpMyAdmin 即可操作 MySQL。可以创建博客使用的数据库。输入数据库名称，然后排序规则选择 utf8_general_ci，单击 创建。 恭喜您！您已经成功部署了 Web 环境，可以开始制作和发布自己的站点了。 卸载一键安装包如果需要卸载一键安装包，执行下列命令： 123chmod 777 -R sh-1.5.5cd sh-1.5.5./uninstall.sh","categories":[],"tags":[]},{"title":"ICE 入门到精通（一）","slug":"ice","date":"2015-08-20T16:00:00.000Z","updated":"2017-06-27T12:33:10.776Z","comments":true,"path":"2015/08/21/ice/","link":"","permalink":"http://91fz.org/2015/08/21/ice/","excerpt":"","text":"ICE 入门到精通（一）关于ICE的介绍，网上的资料有很多，但是从应用的角度上去使用的并不多，在技术革新的今天我们可能更多的是去关注应用领域而非研究领域，因此根据 我个人的使用经验，想对ICE技术做一些总结和介绍。 什么是ICEICE的全称是 Internet Communications Engine网络(互联网)通讯引擎它是由Zeroc公司开发的一套开源中间件系统，与DCOM,CORBA,WEB SERVICE Dcom类似，支持RPC协议，但是在效率上却高于前面所述几种技术方案，是一种适用于各种环境的面向对象的中间件平台：客户和服务器可以用不同的编程语言来编写， 可以运行在不同的操作系统和系统架构上，并且可以使用多种网络技术经行通信（例如TCP、UDP、SSL等），这给我们的应用和部署带来很大的便捷性。 ICE的优点 跨平台，支持多种语言 面向对象编程 为分布式应用方面提供了一整套 强大的特性和功能支持（例如负载平衡、软件分发、数据同步等）。 在网络带宽、内存使用和CPU开销方面已经内置了高效的实现。 内置了安全特征的实现，可跨越不安全的网络（广域网）使用。 降低了复杂性，易于学习和使用。 与WebService的对比优点： 1、走TCP或者UDP，效率上和webservice不是一个等级的。 2、安全性方面比webservice要强 3、.ice文件支持对exception的定义 缺点： 1、如果提供一个服务在公网上 ， 现在提供wsdl毕竟还是主流，貌似没有人提供.ice文件出去。 2、xml文件个人觉得比.ice文件的可读性更强 一些基础的概念和模型首先我们来看看ICE的基础调用模型（如下图所示） Client（客 户端）：估计这个大家都非常清楚，通俗的讲就是一个请求的发起方。 Proxy（代理）：代理实际上就是远程服务驻在本地的一个代表，创建 它时首先会和远程服务经行握手和状态确认等操作，Client所有的操作都是从过Proxy来办理的。代理又分为直接代理（已经知道服务端的位置及其他信 息）和间接代理（不知道服务器在哪里，由Registry注册器告诉它地址等信息）。 Adapter（适配器）：是配置相当于服务单位 （Servant）的管理者，它管理着每个请求该分配给哪一个服务单位。 Servant（服务单元）：它是服务的最小单位，一般是具体到 某个接口的实现。 刚才我们提到了接口的实现，但是这个接口是谁定义的，这个时候我们不免要提到Slice（Specification Language for Ice），也就是ICE所使用的“语言”，正是有了这个“中间语言”，我们才可以做到支持各种编程语言，因为你所使用的语言只要跟Slice打交道就可以了,关于Slice我在后面可能会详细的来讲述。 ICE调用模式ICE采用的网络协议有TCP、UDP以及SSL三 种，不同于WebService，ICE在调用模式上有好几种选择方案，并且每种方案正对不同的网络协议的特性做了相应的选择。 Oneway(单向调用)：客户端只需将调用注册到本地传输缓冲区（Local Transport Buffers）后就立即返回，并不对调用结果负责。 Twoway（双 向调用）：最通用的模式，同步方法调用模式，只能用TCP或SSL协议。 Datagram（数据报）：类似于Oneway调用，不同的是 Datagram调用只能采用UDP协议而且只能调用无返回值和无输出参数的方法。 BatchOneway（批量单向调用）：先将调用存 在调用缓冲区里面，到达一定限额后自动批量发送所有请求（也可手动刷除缓冲区）。 BatchDatagram（批量数据报）：与上类似。 不同的调用模式其实对应着不动的业务，对于大部分的有返回值的或需要实时响应的方法，我们可能都采用Twoway方式调用，对于一些无需返回值或 者不依赖返回值的业务，我们可以用Oneway或者BatchOneway方式，例如消息通知；剩下的Datagram和BatchDatagram方式 一般用在无返回值且不做可靠性检查的业务上，例如日志。 ICE的版本控制（Facet）ICE内部集成非常好的版本 控制功能（Facet），在每一个服务单元（Servant）其实都有一个Facet与之并存，如果你没有认为指定，那么这个默认Facet的值就为空 (String.Empty)。在我们业务的实际应用过程中，经常要碰到服务升级的情况，但是升级服务就意味着增大了原有业务调用的稳定性，从而增大了风 险，这个Facet就刚好解决我们遇到的这个难题，我们每次升级都是“新增服务”，而非改变原有业务，新来的业务调用新版本服务，原有业务调用原有版本服 务。当检测一些很“老”的服务确认无人调用的时候我们就可以关掉了。 Facet的实现其实也非常简单，服务端（Adapter）在挂载服 务（Servant）的时候就制订了相应版本号。这时候客户端要调用此方法就必须提供正确的版本号（而非默认版本号）。 持久化 （Feeze）一款对Servant服务进行管理和持久化的工具，Adapter可以注册多个Servant在内存中，当 Adapter接收到一个新的请求（request）后便去管理列表里面查找是否存在已有的Servant，如果存在则返回该Servant，如果不存在 则实例化一个新的Servant实例。当不停的实现新Servant之后势必会造成内存的激增已经CPU资源的浪费，而且一些很少被调用的Servant 也一直驻存在服务中。为此我们设定服务的Servant的上限，到达该上限后自动将“最少调用”的Servant状态保存在数据库（或文件等持久化设备） 中，然后关闭这些Servant，一旦有新的请求此Servant时再次获取原状态来激活Servant…… 服务装箱管理 （ICEBox）从名字就可以看出来，它是一款装箱托管方案，类似于IIS，可以托管多个应用服务，并且每个服务是支持插拔式管理的， 相互之间不受影响，对ICE的应用做了接口设计，每个服务只是实现了 Ice.Services接口就可以了，这样一样让我们可以更专注的关于于我们的业务而非运行的平台。它为我们提供了统一的托管平台，是一个很不错的工 具。 文件分发（ICEPatch2）ICE最重要的功能就是多节点部署，以达到负载平衡或者容灾的目的，大多数时候 每个节点（一般而言是一台服务器）配置的应用程序都是一样的，当每次有更新或者新增应用的时候，便需要手工同步每个节点的文件，这样的手工操作显得十分繁 琐而且完全依赖操作人的行为。而ICEPatch2解决了这一难题，只要有一台以为的ICEPatch2服务在运行当中，就可以通过分发的方式同步其他各 个节点的文件，也就是说运维人员只需要维护一台机器的应用程序文件就可以了。 发布/订阅 服务（ICEStorm)网络拓扑负载解决方案（ICEGrid）终极武器icegrid实际上是一系列组件的组合，形成了 一套强大的 文件分发、负载均衡、快捷部署等解决方案。这也是ICE功能中最为强大的一套，至于细节，有待后文慢慢道来。 学习ICE，我们要从ICE的“语言”学起，简称SLICE（Simple Language Of ICE）。SLICE有自己独立的语法体系和结构，我们必须必须熟悉和遵守这些语法体系才能到达我们想要的效果。 这些就是关于ICE的简单介绍 下一篇我会将iCE 中间语言的语法已经自己写一个简单的demo","categories":[{"name":"ZEROC_ICE","slug":"ZEROC-ICE","permalink":"http://91fz.org/categories/ZEROC-ICE/"}],"tags":[{"name":"ICE","slug":"ICE","permalink":"http://91fz.org/tags/ICE/"}]},{"title":"关于RPC的总结","slug":"rpc","date":"2015-08-19T16:00:00.000Z","updated":"2017-06-27T11:42:32.187Z","comments":true,"path":"2015/08/20/rpc/","link":"","permalink":"http://91fz.org/2015/08/20/rpc/","excerpt":"","text":"关于RPC相信大家的都对RPC框架很熟悉，但有人经常混淆 所以写一篇文章简单介绍下，写的不好 欢迎底下评论留言 什么是RPC它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。 通俗点就是它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。 RPC起源RPC 这个概念术语在上世纪 80 年代由 Bruce Jay Nelson 提出。这里我们追溯下当初开发 RPC 的原动机是什么？在 Nelson 的论文 “Implementing Remote Procedure Calls“ 中他提到了几点： 简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。 高效：过程调用看起来十分简单而且高效。 通用：在单机计算中过程往往是不同算法部分间最重要的通信机制RPC 结构Nelson 的论文中指出实现 RPC 的程序包括 5 个部分： User User-stub RPCRuntime Server-stub Server 这 5 个部分的关系如下图所示 RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。 客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy 。 代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。 在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel， 并使用 RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。 RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（decode）。 解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果 这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。 RPC 组件职责上面我们进一步拆解了 RPC 实现结构的各个组件组成部分，下面我们详细说明下每个组件的职责划分。 RpcServer负责导出（export）远程接口 RpcClient负责导入（import）远程接口的代理实现 RpcProxy远程接口的代理实现 RpcInvoker客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回服务方实现：负责调用服务端接口的具体实现并返回调用结果 RpcProtocol负责协议编/解码 RpcConnector负责维持客户方和服务方的连接通道和发送数据到服务方 RpcAcceptor负责接收客户方请求并返回请求结果 RpcProcessor负责在服务方控制调用过程，包括管理调用线程池、超时时间等 RpcChannel数据传输通道 RPC 实现分析在进一步拆解了组件并划分了职责之后，这里以在 java 平台实现该 RPC 框架概念模型为例，详细分析下实现中需要考虑的因素。导出远程接口导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。 在 java 中导出接口的代码片段可能如下： 1234DemoService demo =new...;RpcServer server =new...;server.export(DemoService.class, demo, options); 我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如： 123// 只导出 DemoService 中签名为 hi(String s) 的方法server.export(DemoService.class, demo,&quot;hi&quot;,newClass&lt;?&gt;[] &#123; String.class&#125;, options); Java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？ 这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。 如果前面 DemoService 接口有2个实现，那么在导出接口时就需要特殊标记不同的实现，如： 12345DemoService demo =new...;DemoService demo2 =new...;RpcServer server =new...;server.export(DemoService.class, demo, options);server.export(&quot;demo2&quot;, DemoService.class, demo2, options); 导入远程接口与客户端代理导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。 目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码， 这种方式下实际导入的过程就是通过代码生成器在编译期完成的。 我所使用过的一些跨语言平台 RPC 框架如 CORBAR、WebService、ZEROC-ICE、Thrift 均是此类方式。 代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。 在 java 中导入接口的代码片段如下： 1234RpcClient client =new...;DemoService demo = client.refer(DemoService.class);demo.hi(&quot;how are you?&quot;); 在 java 中 import 是关键字，所以代码片段中我们用 refer 来表达导入接口的意思。 这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。 java 里至少提供了两种技术来提供动态代码生成，一种是 jdk 动态代理，另外一种是字节码生成。 动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。 两者权衡起来，牺牲一些性能来获得代码可读性和可维护性显得更重要。协议编解码客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。 出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。 我们先看下需要编码些什么信息： 调用编码 接口方法 包括接口名、方法名 方法参数 包括参数类型、参数值 调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等返回编码 返回结果接口方法中定义的返回值 返回码 异常返回码 返回异常信息 调用异常信息除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。 这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。 如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。 下面给出一种概念上的 RPC 协议消息设计格式： magic : 协议魔数，为解码设计 header size: 协议头长度，为扩展设计 version : 协议版本，为兼容设计 st : 消息体序列化类型 hb : 心跳消息标记，为长连接传输层心跳设计 ow : 单向消息标记， rp : 响应消息标记，不置位默认是请求消息 status code: 响应消息状态码 reserved : 为字节对齐保留 message id : 消息 id body size : 消息体长度 消息体采用序列化编码，常见有以下格式 xml : 如 webservie SOAP json : 如 JSON-RPC binary: 如 thrift; hession; kryo 等格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。 序列化我们关心三个方面： 序列化和反序列化的效率，越快越好。 序列化后的字节长度，越小越好 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。 传输服务协议编码之后，自然就是需要将编码后的 RPC 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。 RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。 因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。 既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？ 实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。 单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区， 因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。 所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升， 反而会增加连接管理的开销。 连接是由 client 端发起建立并维持。 如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。 如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。 为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。 心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位， 就是用来标记心跳消息的，它对业务应用透明。 执行调用client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。 server stub 从前文的结构拆解中我们细分了 RpcProcessor 和 RpcInvoker 两个组件， 一个负责控制调用过程，一个负责真正调用。 这里我们还是以 java 中实现这两个组件为例来分析下它们到底需要做什么？ java 中实现代码的动态接口调用目前一般通过反射调用。 除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用， 因此 RpcInvoker 就是封装了反射调用的实现细节。 调用过程的控制需要考虑哪些因素，RpcProcessor 需要提供什么样地调用控制服务呢？ 下面提出几点以启发思考： 效率提升每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。 资源隔离当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。 超时控制当某个接口执行缓慢，而 client 端已经超时放弃等待后，server 端的线程继续执行此时显得毫无意义。RPC 异常处理无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。 在说异常处理之前，我们先比较下本地调用和 RPC 调用的一些差异： 本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。本地调用只会抛出接口声明的异常，而远程调用还会跑出 RPC 框架运行时的其他异常。本地调用和远程调用的性能可能差距很大，这取决于 RPC 固有消耗所占的比重。正是这些区别决定了使用 RPC 时需要更多考量。 当调用远程接口抛出异常时，异常可能是一个业务异常， 也可能是 RPC 框架抛出的运行时异常（如：网络中断等）。 业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行， 而 RPC 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。 由于 RPC 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。 那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务， 只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。 常见的 rpc 框架 double grpc motan thrift avro 性能对比下一篇讲一讲性能最好的 ZeroC——ICE","categories":[{"name":"RPC","slug":"RPC","permalink":"http://91fz.org/categories/RPC/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"http://91fz.org/tags/RPC/"}]},{"title":"QQ实用技术（从以前的博客拿过来的2011年手机写的 纯粹怀旧）","slug":"QQ技术","date":"2015-08-10T16:00:00.000Z","updated":"2017-06-27T09:44:00.249Z","comments":true,"path":"2015/08/11/QQ技术/","link":"","permalink":"http://91fz.org/2015/08/11/QQ技术/","excerpt":"","text":"QQ实用技术（从以前的博客拿过来的2011年手机写的 纯粹怀旧）首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！盗取QQ的方式有 (1)远程木马盗号 (2)强制破解 (3)键盘纪录 (4)钓鱼网站，-(5)恶意申诉 第一种方法《远程木马盗号》远程木马盗号的软件有“盗Q黑侠，广外幽灵，QQ机器人，QQ远程攻击器，QQ流感，阿拉QQ大盗，QQ explorer QQ密码使者等， 它们的使用都差不多。我用的是QQ邮箱收信，去邮箱设置里把软件地址设为白名单，例如:gzf@qinan.me，然后填写收件地址(这个区别前面的是要盗的号的邮箱)。还有发件地址(就是你收密码和发邮件的邮箱). 第二步，生成木马(这个是软件自带) 第三步 相当重要，重命名该木马，取一个吸引人的名字，例如:美女裸照，然后修改后缀(这个可以百度搜软件)，木马一般都是可运行程序，后缀是exe，要骗警惕的人不容易，那我们可以把他换成图片后缀(jpg，gif，等)音乐后缀(mp3，wma等)视频后缀(mp4，Avi，flv，mrvb，等) 第四步，发邮件，一般把木马藏在附件里面，然后等那人运行木马后，我们可以在邮箱里查看密码和IP， 第二种方法是《本地破解》这种成功率低的伤不起，之所以我用过，因为比较简单，就是用QQ暴力破解，下载词典，然后输入QQ号码，先猜可能的密码，例如:我确定某人的密码是纯数字，就选数字词典，然后就等待破解，如果有字母就在词典里加字母就可以了。 第三种《键盘纪录》这种在网吧比较好用，下载键盘纪录软件(一定要能躲过还原精灵的那种，如果家庭电脑就没必要)注意点有二，第一要安装正确，二记住键盘输入纪录所在文件夹，这个是最简单的，可以直接查看。但是，如果用软件盘输入它就无能为力了！嘿嘿！ 第四种就是《恶意申诉》这个成功油水肥，可以改密保问题，是我常用的一种，申诉大家都会，不多说，注意点有，你必须有2个以上的小号，加的目标号码时间越长成功率越高，三不知道的不要乱猜，据我的经验，一般申请的都是网页免费申请，不多说，具体操作，自己把握，第五钓鱼网站，这个从去年开始比较流行，现在中毒转发减肥和色 情聊天的都是这么中毒的，这个需要熟悉网站制作，要求比较高，比较麻烦，就不多说！ 下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单1，拒绝好奇心不要接收陌生人的离线文件，熟人不知道什么东西的情况下就也不乱接，包括邮件里面的附件。（尤其多人转发的那种邮件） 2，IP代理再QQ登录框下面的高级设置里(找不到你的iP地址木马无法攻击)键盘纪录防范，只要软键盘输入就行了， 3，暴力破解防范密码越复杂越好，你数字中加一个标点符号，破解难度就得翻几倍。 4，恶意申诉只有一个办法，绑钉自己身份证(前提是别人不知道你的身份证号码和姓名) 5，鱼肉，记住一句话就可以，天上不掉馅饼，掉陷井，不要去玩色 站，和黑基，开挂等。 6看好友隐身和ip地址的软件qq彩虹 赛博qq 从初三玩 qq有6，7年了 以上就是我对各位童鞋的各种悲剧的一些建议！（以前用手机写的 还记得是Mtk的，纯粹为了怀旧，以上软件用不了）","categories":[{"name":"以前","slug":"以前","permalink":"http://91fz.org/categories/以前/"}],"tags":[{"name":"盗取QQ,QQ技术","slug":"盗取QQ-QQ技术","permalink":"http://91fz.org/tags/盗取QQ-QQ技术/"}]},{"title":"安装ZeroC-ICE","slug":"安装Zero-ICE","date":"2015-08-09T16:00:00.000Z","updated":"2017-06-26T09:52:15.652Z","comments":true,"path":"2015/08/10/安装Zero-ICE/","link":"","permalink":"http://91fz.org/2015/08/10/安装Zero-ICE/","excerpt":"","text":"ubuntu 安装1234567891011121314151617181920212223242526272829303132wget https://zeroc.com/download/GPG-KEY-zeroc-release sudo apt-key add GPG-KEY-zeroc-release sudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot; sudo apt-get update sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devwget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devUbuntu 15.04wget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu15.04 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devUbuntu 14.04wget https://zeroc.com/download/GPG-KEY-zeroc-releasesudo apt-key add GPG-KEY-zeroc-releasesudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu14.04 stable main&quot;sudo apt-get updatesudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-devGPG KeyThe Linux binary distributions are signed with our release key.Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997Sample ProgramsA collection of sample programs are available on GitHub. You can download them by running the following command:git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.gitRefer to GitHub&apos;s help page for more information. centos 安装123456789101112131415161718192021222324 Install on Red Hat Enterprise LinuxDocumentation: Using the Linux Binary DistributionsIncludes: Runtime and SDK for Ice for C++, Java, PHP, and all Ice services.Red Hat Enterprise Linux 7Prerequisite: You may need to enable the RHEL 7 Server Optional repository for several dependencies.cd /etc/yum.repos.dsudo wget https://zeroc.com/download/rpm/zeroc-ice-el7.reposudo yum install ice-all-runtime ice-all-develRed Hat Enterprise Linux 6cd /etc/yum.repos.dsudo wget https://zeroc.com/download/rpm/zeroc-ice-el6.reposudo yum install ice-all-runtime ice-all-develGPG KeyThe Linux binary distributions are signed with our release key.Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997Sample ProgramsA collection of sample programs are available on GitHub. You can download them by running the following command:git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.gitRefer to GitHub&apos;s help page for more information. ** 下一篇介绍用法","categories":[],"tags":[]},{"title":"自己刷机的一些感触和经验","slug":"rom","date":"2012-10-10T16:00:00.000Z","updated":"2017-06-27T10:35:22.189Z","comments":true,"path":"2012/10/11/rom/","link":"","permalink":"http://91fz.org/2012/10/11/rom/","excerpt":"","text":"自己刷机的一些感触和经验首先我要说一下，其实，刷机的最高境界就是不刷，连超级权限就是root都不要，这是我这段时间的一些感触。 对于root这个问题有些人认为可以卸载系统软件，美化字体，等等好处，但是，木马也会在你不知情的情况下获得超级权限，而且可以饶过全软件，从而获取你手机里的所有信息，我想，很少有人希望他成为第二个陈冠希吧！ 关于解锁关于解锁，我还是希望轻易不要去解，因为你一解锁，手机厂商会不保修的，而且要再次锁手机，只有强刷官方固件，虽然简单，但许多官方固件是锁不住的！如果看了上面这些你还是选择刷机，那么看下面的内容，也许对你有帮助！ 关于ROOT首先，我说下root吧，各种手机root的方法不一样，普遍的2.3左右的系统的话（安卓一键root）和（刷机精灵）是可以解决的，但是4.0的要按自己的手机型号找软件，有点麻烦，root一般不会出现问题，失败了重新来遍就可以了。。 第二步，就是刷入recovery，各种版本的用法不一样，像刷机精灵自带的5.04英文版的确定是关机健，刷recovery首先要让手机进入recovery模式，各种手机的操作方式网上都有，我就不说了，这要注意一点就是要确保adb驱动，usb调试没任何问题，然后根据工具的提示走就可以，这一步是不会成转的，但这一步刷不好，后面刷rom的时候成转可能比较大 第三步，下载你喜欢的rom，选择的时候看下评论，漏洞多不多，系统流畅度怎么样，费电程度等都是考虑因素，把下载好的固件放入内存卡中 关于刷机卡刷法也就是recovery刷法，步骤如下… 当然前提是你手机已经root过了！ 关掉快速启动，- 开机进入模式（手机型号不同，方法不同，自己网上找自己手机进入模式的方法） 然后选择清空缓存和数据，如果不双清，肯定成转， 选择从sd卡选择zip安装，过程大概在几十秒，然后返回重启手机，第一次启动速度有点慢，属于正常情况。 线刷法前提是也是要root过！线刷的话，失败了后救砖是比较麻烦，而且对数据连接要求高，就是再刷机过程中如果数据线连接不好就容易失败，救砖的话不好救，所以线刷之前还是刷一次recovery，以防失败后救砖， 把下载好的固件包放在线刷工具可以导到的目录下， 然后启动工具，工具自己找，刷机大师，精灵都是可以的，然后连接手机，（确保usb..adb模式开启）， 然后按步骤导入固件包，进行云检测，然后你可以休息了，它自己会解锁手机，把包刷进手机，自动进行刷机，这个时间有点长，刷完自动重启，关于救砖 （1）手机是否刷过recovery （2）手机是否可以进入fastboot模式 （3）手机是否可以进行强刷官方固件 如果说你手机刷过recovery，这就简单了，多下载几个rom包进行卡刷或者线刷，救砖我比较推荐用线刷，如果还不行就强刷官方固件，如果手机可以进入fastboot模式，那也好办，重刷recovery，然后进行卡刷，不行在线刷，实在不行强刷官方固件。 总结：如果以上方法都不行，那只剩强刷官方固件这一条路了，以C8812为例，下载官方固件，把一个dload文件夹放到手机自带内存的根目录下，关机，然后按住音量加和音量减和开机键，记得，是同时按住’，他会自动升级，时间大概三四分钟，如果出现粉屏，那你一定是把文件考到内存卡里了，而没考在手机自带内存中，就这些吧，手机打字不容易，希望大家多多支持**","categories":[{"name":"以前","slug":"以前","permalink":"http://91fz.org/categories/以前/"}],"tags":[{"name":"刷机","slug":"刷机","permalink":"http://91fz.org/tags/刷机/"}]},{"title":"ROM修改之厨房简介及环境配置","slug":"Kitchen","date":"2012-10-09T16:00:00.000Z","updated":"2017-06-27T10:14:45.333Z","comments":true,"path":"2012/10/10/Kitchen/","link":"","permalink":"http://91fz.org/2012/10/10/Kitchen/","excerpt":"","text":"ROM修改之厨房简介及环境配置 **一.厨房简介及环境配置1.厨房简介厨房，是HTC android厨房的简称，是一款由国外ROM达人写的与DOS程序相似的ROM修改程序，目前各版本介绍及更新主要发布于国外著名玩机论坛XDA- Developers, 目前发布有linux版本和windows版本,在这里,花小祺只为大家介绍windows版本 2.厨房支持的机型（ROM）1）HTC设备 Buzz / Wildfire Desire Desire HD / Inspire 4G Desire S Desire Z Dream / G1 Droid Eris Evo 4G Evo Shift 4G HD2 Hero / G2 Touch Incredible Incredible S Legend Magic / myTouch 3G myTouch 3G Slide myTouch 4G / Glacier Nexus One Tattoo / Click Thunderbolt理论支持一些其他机型的已Root的HTC手机（android操作系统）也有可能支持一些WindowsMobile等可以使用Android NAND ROM的机型 2）非HTC设备： 戴尔 Streak 7 华为 U8100/U8110/U8120/U8150 LG Ally LG GT540 Optimus LG P500 LG Shine Plus LG Vortex 摩托罗拉 CLIQ / CLIQ XT 三星 Galaxy S - You must use RMGeren’s SGS version of this kitchen 三星 Nexus S•索爱 Xperia X10 / X10 Mini / X10 Mini Pro - 不含 boot.img T-Mobile Pulse 3）理论支持设备（还没正式确定） 摩托罗拉Droid 摩托罗拉Milestone（修改前需移除boot.img文件） 由于我的电脑室win7系统 所以就以win7为例安装方法：首先学java语言的同学肯定自己电脑上已经配置好java环境了可以直接省略安装JDK这一步： 下载后直接全默认安装JDK 最好默认C盘，如果在别的盘，下面的路径自行对应修改 设置环境变量：JAVA_HOME、PATH、CLASSPATHJAVA_HOME：我的电脑-&gt;属性-&gt;高级-&gt;单击“环境变量”按钮-&gt;单击“系统变量”区域的“新建”按钮-&gt;在“变量名”文本框中输入JAVA_HOME，在“变量值”文本框中输入JDK的安装路径（列如C:\\Program Files\\Java\\jdk1.6.0_22）,单击确定 PATH：在系统变量中查看PATH变量，如果存在PATH，则在最末尾多添加一个%JAVA_HOME%\\bin;（直接添加，无需加空格之类的）。如果不存在，则新建变量PATH，设定变量值为：%JAVA_HOME%\\bin;CLASSPATH：在系统变量中查看CLASSPATH变量，如果存在CLASSPATH，则在最末尾添加%JAVA_HOME%lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar。如果不存在，则新建一个，设定变量值为：%JAVA_HOME%lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;完成以上步骤后，开始验证是否安装成功。运行CMD（开始，运行，输入cmd，回车），输入：javac。假如出现了一堆如何使用java的帮助，那就是已经安装成功了。 第二步。安装cygwin 解压下载到的压缩包（比如解压到C盘，解压出来的东西包括：cygwin_packages文件夹、setup.exe、安装说明.txt），记得路径中不要带中文，最好也不要带空格。 运行 Setup.exe 安装程序 选择 “Install from Local Directory“，然后点击 Next （下一步）。 接下来，指定根目录。也就是你想要安装 Cygwin 的位置(但不能是本压缩包解压出来的 cygwin_packages 文件夹)。如果你喜欢，可以是C:\\Cygwin，注意要确定文件夹名种没有空格。然后点击 Next （下一步） 然后，指定 Local Package Directory，必须指定为 cygwin_packages 文件夹所在路径（且cygwin_packages下级目录必须是英文（这一步有这样一个注意点，路径一定要指到cygwin_packages ）。假如跳出了一个警告对话框，点击yes（是）。 当安装程序显示出所有的包名时，点击上方第一个的 “All &lt;-&gt; Default“ 为 “All &lt;-&gt; Install“ (点击那个环形箭头符号)（这一步有比较长的进度条） 然后点击 Next （下一步），安装程序就会为你安装好 Kitchen 需要 Cygwin 提供的一切支持 最后，点击桌面上的 Cygwin 快捷方式以便为你创建 home 文件夹。（如果此步一闪而过注意检查上面的步骤） 最后，开始使用厨房： 完成上面的步骤后，将下载到厨房解压到C:\\Cygwin\\home\\Administrator（如果是你设置了自己的登录名，那么Administrator就变成你自己的用户名就行了，同理如果你不是在C盘，做相应变化）也就是说，解压完厨房，C:\\Cygwin\\home\\Administrator目录下必有：original_update，scripts，tools，menu这几个厨房文件 点击桌面上的 Cygwin 快捷方式 执行命令：./menu正式开始使用厨房定制ROM厨房很强大，可以支持很多ROM，不管是官方的还是民间的，这里我能力有限只能稍微介绍怎么提取并修改官方ROM，其他ROM大家可以自己摸索。 1，把拷贝出来的rom.zip复制到U盘中，通过U盘把提取的ZIP复制到虚拟机中。2，打开zip文件，或者解压zip文件，把里面的boot.img和system.img拷贝到桌面的“到original update的链接”文件夹中。3，运行桌面的“到menu的链接”，点击在终端中运行。(这一步好像有时候不行，按菜单功能不能进入，如果不行的话，大家只能打开主文件夹，双击menu打开。或者在附件-终端中输入“./menu”打开厨房了)4，根据屏幕提示：选择1，按回车，再按回车，在按1选择刚才拷入的boot.img和system.img，按回车后就开始分解img文件了。分解后提示查看ROM的一些信息，根据需要Y或者N，回车。5，根据菜单上的功能按相应的数字键进入。并根据提示完成定制。配置完，在主菜单选择99按回车可以打包定制目录，自动生成ROM。文件夹在主目录的output文件夹中（菜单栏-位置-主文件夹）。按上面的方法创建output文件夹的快速链接，并放到桌面去。方便以后打开。6，把zip拷贝到U盘。再拷贝到手机内存卡。然后接下来大家都懂得。或者直接把手机通过可移动磁盘接入到虚拟机中也可以。操作和U盘一样。厨房菜单功能简单介绍： Main Menu（主菜单） Set up working folder from ROM（从ROM文件导入到工作文件夹） Add root permissions（加入ROOT权限） Add BusyBox（加入BusyBox） Disable boot screen sounds（禁止启动音乐） Add wireless tethering（加入WIFI共享） Zipalign all *.apk files to optimize RAM usage（对所有apk进行Zipalign，进行程序内存优化） Change wipe status of ROM（刷机时清除机器数据和缓存，但不包括SD-ext分区） Change name of ROM（更改ROM的名称） Check update-script for errors（检查update-script升级脚本是否有错误） Show working folder information（显示工作目录下rom的信息）Advanced Options（增强定制选项） 11 - Deodex files in your ROM （Deodex ROM中的文件，就是把system/app下的APK和ODEX合并为一个apk文件，以便进行更新系统软件） 12 - Add task killer tweak for speed (stock ROM only)（加入Android内存优化用以加快速度，只适用于官方ROM） 13 - Add /data/app functionality（加入自定义可卸载程序存放目录，放在这里面的程序刷机后可以卸载，刷完格式化手机也会丢失） 14 - Add Nano text editor + sysro/sysrw（加入Nano文本编辑器，System目录的只读和读写转换） 15 - Add Bash (command shell)（加入Shell命令集） 16 - Add Apps2SD（加入Apps2SD功能，就是A2SD+之类的） 17 - Add /etc/init.d scripts support (busybox run-parts)（加入对/etc/init.d目录下脚本运行的支持） 18 - Add custom boot animation functionality（加入自定义开机动画的支持） 19 - Porting tools (experimental)（移植工具，仅测试） 20 - Unpack or re-pack a boot.img（打包或解包boot.img） 21 - Unpack data.img （分解data.img） 22 - Sign APK file(s)（签名apk安装包） 23 - Convert update-script or updater-script（转换update-script 或者updater-script） 24 - Run plugin scripts（运行插件脚本之类的）Build ROM from working folder（将工作目录下的ROM打包，打包完就可以刷机了。） About/Update kitchen（厨房的升级，关于） X. Exit（退出）","categories":[{"name":"以前","slug":"以前","permalink":"http://91fz.org/categories/以前/"}],"tags":[{"name":"ROM修改","slug":"ROM修改","permalink":"http://91fz.org/tags/ROM修改/"}]},{"title":"让国产山寨手机死机黑屏之imy","slug":"imy","date":"2011-11-14T16:00:00.000Z","updated":"2017-06-27T09:41:50.457Z","comments":true,"path":"2011/11/15/imy/","link":"","permalink":"http://91fz.org/2011/11/15/imy/","excerpt":"","text":"让国产山寨手机死机黑屏之imy IMY铃声是一段铃声代码文件，具有占有空间小、容易编辑等特点。中国移动规定其为通用彩信文件格式之一,可以用短信进行收发（当然不花流量咯！）。IMY标准非常灵活，音域跨了9个8度，24种不同音长；还可以加入振动、屏幕背光及来电灯亮灭的效果，给人以更加美妙神奇的音乐体验。 怎样看你的手机是否支持IMY铃声？ 短信编辑界面，选项——插入对象——我的铃声/预设铃声。（IMY铃声文件在短信中会以音符的图标显示。） 若能进行上述操作，则恭喜你，你的手机支持IMY;若“我的铃声”为空白，则你的手机闪存（人们习惯上将其错叫成“手机内存”）里的“audio”文件夹里没有IMY铃声。) imy可传播手机病毒吗？ 2008年11月以来，很多人收到了一些“黑屏短信”、“死机短信”、“狂振、狂闪短信”，这些短信是怎么做到的呢？又是不是病毒呢？ 了解了IMY的本质，就不难回答上面的问题（请看上文加粗的文字）。这也正是“山寨机”容易中招的原因。 那些短信中包含有一些恶作剧的IMY铃声文件。以黑屏短信为例，这个IMY铃声文件不含声音代码，而只含有关闭背光、来电灯以及振动的命令（下面将会进一步详解），让人误认为是死机。笔者亲自试过，这个文件只会让手机黑屏73秒，并非真死，并且对手机无害。 IMY铃声调用的命令仅仅是声音指令、振动开启及关闭指令、屏幕背光和来电灯亮灭指令。所以并非病毒。虽不是病毒，但手机狂振、狂闪却应该是对手机有伤害的。 那么，如何删除带有这种恶作剧IMY铃声文件的短信呢？ ——调成静音模式，然后删除。原因是静音模式时，IMY铃声就不会播放，其中的恶作剧就不会得逞。呵呵~ 还是强烈倡议大家“和平使用”IMY铃声。过犹不及嘛，恶作剧也应有个度。 IMY铃声恶作剧例子 黑屏： 1234 BEGIN:IMELODY BEAT:1200 MELODY:(ledoffbackoffvibeoffr5ledoffbackoffvibeoffr5@600) END:IMELODY 狂震： 12345678 BEGIN:IMELODY VERSION:1.2 FORMAT:CLASS1.0 BEAT:100 MELODY:(ledoffledonbackoffbackonvibeon@300) END:IMELODY 振铃：123456 BEGIN:IMELODY VERSION:1.2 FORMAT:CLASS1.0 BEAT:200 MELODY:(ledoffbackoffvibeonr5vibeoffledonbackonr5@200) END:IMELODY IMY铃声代码详解 其实IMY铃声文件本无罪，所以大家不要被恶作剧吓到。 下面通过《生日快乐歌》的代码，来详细了解一下IMY代码格式。（两排#号间为要存储为.imy文件中的内容；引号及其中间内容为代码解释，实际代码中没有；“MELODY旋律字符串”中的空格也是为了大家看的更明白而加上的） *注意：代码一律用英文半角字符.12345678910 BEGIN:IMELODY VERSION:1.2 “版本号” FORMAT:CLASS1.0 “格式编号。取值CLASS1.0或CLASS2.0，前者居多” NAME:HAPPY BIRTHDAY “铃声名。可缺省” COMPOSER:MTK(13) “演奏乐器。可缺省” BEAT:165 “节奏。取值从25到900bpm（拍/分钟），越大节奏越快，缺省值120” STYLE:S0 “风格。取值为S0；S1；S2；缺省值S0” VOLUME:V10 “音量。取值V0到V15。V0为静音，缺省值V7” MELODY:(*3a2 V+ a2 #f2 d2 #c2 *3b1 g2 #f2 d2 V- e2 vibeon ledon backoff d1 vibeoff ledoff backon @2) “旋律字符串” END:IMELODY 12345678910111213141516171819202122“风格STYLE”中 S0：普通。每音符间有暂停，音符与暂停时间比为20:1 S1：持续。每音符间无暂停 S2：断奏。音符与暂停时间比为1:1“旋律字符串MELODY”中的特效命令 “vibeon”、“vibeoff” 分别为振动开启，停止命令； “ledoff”、“ledon” 分别为来电灯关闭、开启命令； “backoff”、“backon” 分别为屏幕背光关闭、开启命令； &quot;(&quot;+&lt;melody&gt;+&quot;@n)&quot; 为重复特效,n取值0到无穷（0为无限重复）“旋律字符串MELODY”中的音符格式 &lt;音阶&gt;&lt;升降调&gt;&lt;具体唱名&gt;&lt;音长&gt;&lt;延时符&gt; &lt;音阶&gt;：取值 “*0”、“*2”、… “*8”；(a=55Hz) | (a=110Hz) | … | (a=14080 Hz) 缺省&quot;*4&quot;，代表标准音（小字一组a音为880Hz）。 &lt;升降调&gt;：“#”代表升半音，d、g、a、c、f前可加“#”； “&amp;”代表降半音，d、g、a、b、e前可加“&amp;”。 &lt;具体唱名&gt;：c、d、e、f、g、a、b。 &lt;音长&gt;：数值&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot;，分别为全音符、半音符、1/4音符...1/32音符。 &lt;延时符&gt;：“.” | “:”| “;” ;延时符，1.5倍、1.75倍与2/3倍。“旋律字符串MELODY”中的休止符 r0，r1，r2，r3，r4，r5；停顿时长分别为全音符、半音符、1/4音符...1/32音符 。 其后同样可加延时符，如“r3.”。“旋律字符串MELODY”中音量控制 V+，V-。 怎样获得imy铃声文件？ 可以DIY。网上有一些制作imy铃声的软件，可以用他们来DIY也可以用一些软件来将其他格式的音乐转换成imy格式。还可以在网上找一些代码的文本，复制到记事本里，把文件后缀”.txt”改成”.imy”，保存到手机闪存的“audio”文件夹里即可。 OK，现在就用浪漫十足的IMY铃声来扮炫你的生活吧！！！","categories":[{"name":"以前","slug":"以前","permalink":"http://91fz.org/categories/以前/"}],"tags":[{"name":"moblie","slug":"moblie","permalink":"http://91fz.org/tags/moblie/"}]}]}