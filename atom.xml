<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员疯子的博客-Code is Art, Code is Poetry!</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://91fz.org/"/>
  <updated>2017-07-01T16:13:47.648Z</updated>
  <id>http://91fz.org/</id>
  
  <author>
    <name>Fengzijk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈服务治理与微服务</title>
    <link href="http://91fz.org/2017/06/27/fuwu01/"/>
    <id>http://91fz.org/2017/06/27/fuwu01/</id>
    <published>2017-06-26T16:00:00.000Z</published>
    <updated>2017-07-01T16:13:47.648Z</updated>
    
    <content type="html"><![CDATA[<p>近期都在大谈微服务，本人也在做相关的工作已经两年左右了，做了一个微服务的分享，整理了这篇文章，有问题可以在下面留言，可以和大家一起讨论。    </p>
<p>先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。</p>
<h2 id="互联网架构演变"><a href="#互联网架构演变" class="headerlink" title="互联网架构演变"></a>互联网架构演变</h2><h3 id="单体体架构"><a href="#单体体架构" class="headerlink" title="单体体架构"></a>单体体架构</h3><p>在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。 如下图：</p>
<p><img src="/images/fuwu/01.png" alt="image"><br><img src="/images/fuwu/02.png" alt="image"></p>
<ul>
<li><strong>单体式应用的优点明显：</strong><br>现有IDE都是集成开发环境，非常适合单体式应用，开发、编译、调试一站式搞定。<br>一个应用包含所有功能，容易测试和部署。<br>运行在一个物理节点，环境单一，运行稳定，故障恢复简单。</li>
<li><strong>单体式应用的缺点也明显：</strong><br>业务边界模糊，模块职责不清晰，当系统逐渐变大，代码依赖复杂，难以维护。<br>所有人同时在一个工程上开发，容易发生代码修改冲突，依赖复杂导致项目协调困难，并且局部修改影响不可知，需要全覆盖测试，需要重新部署，难以支持大团队并行开发。<br>当系统很大时，编译和部署耗时。<br>应用水平扩展难，一方面状态在应用内部管理，无法透明路由；另<br>一方面，不同模块对资源需求差异大，当业务量增大时，一视同仁地为所有模块增加机器导致硬件浪费。</li>
</ul>
<h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><p>但随着浏览器的出现便产生了<strong>web</strong>应用，<strong>web</strong>应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css+js+html技术来处理，而后端可以用<strong>Java</strong>、<strong>PHP等语言</strong>，这就产生了前后端分离。对于<strong>web</strong>系统，一体架构难以满足前后端分离的开发需求，因而便产生了<strong>MVC</strong>架构。<br><strong>为什么我把Mvc但那处处呢，因为他也有划时代的意义，其实从大方向讲MVC架构也是单体架构的一种</strong>   </p>
<p><strong>MVC架构如下图：</strong><br><img src="/images/fuwu/03.png" alt="image"></p>
<p>MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。</p>
<p>但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了<strong>多应用架构</strong>。</p>
<h3 id="多应用架构"><a href="#多应用架构" class="headerlink" title="多应用架构"></a>多应用架构</h3><p>多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。<strong>如下图：</strong><br><img src="/images/fuwu/04.png" alt="image"></p>
<p><strong>多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。</strong></p>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。</p>
<p>因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。</p>
<p>在分布式应用架构中，应用相互独立，每个应用代码独立开发，独立部署，应用通过有限的API接口互相关联。API接口属于应用一部分，一般和表示层处于同一层次，两者共享业务逻辑层，API和表示层采用同样的web端技术，通讯协议一般使用HTTP，数据格式是JSON，应用集成方式比较简化。</p>
<p>分布式架构首先对系统按照业务进行垂直切分，把系统切分为不同应用，针对资源需求特点（比如<strong>CPU/IO/存储密集型</strong>），通过加强硬件配置满足不同应用的需求，避免一刀切方式带来的资源浪费。<br><img src="/images/fuwu/05.png" alt="image"></p>
<p>技术上，<strong>API</strong>采用标准的<strong>HTTP/JSON</strong>进行通讯，调用双方实现难度都不大，但是API一般是“裸奔”的，在系统层面，调用依赖关系不透明，调用可靠性缺乏保障，因此只适用应用之间依赖链路少，调用量不大的系统，即应用之间耦合确实够松的系统。   </p>
<h3 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h3><p>有人说<strong>SOA</strong>就是分布式，其实这个界限有点模糊，不过相比较普通<strong>API</strong>方式，<strong>SOA架构更进一步</strong>： </p>
<ul>
<li>每个<strong>service</strong>都是浓缩的精华，聚焦某方面核心业务，同时以复用的方式供整个系统共享。 </li>
<li>服务作为独立的应用，独立部署，接口清晰，很容易做自动化测试和部署。 </li>
<li>服务是无状态的，很容易做水平扩展；通过容器虚拟化技术，实现故障隔离和资源高效利用，业务量大的时候，加机器即可。 </li>
<li>基于SOA的系统可以根据服务运行情况，灵活调控服务资源，包括服务上下架、服务升降级等，使系统真正具备可运营的能力。</li>
<li>当然天下没有免费的午餐，<strong>SOA</strong>也带来了额外复杂性和弊端： </li>
<li>系统依赖复杂，给开发/测试/部署带来一系列挑战。 </li>
<li>端到端的调用链路长，可靠性降低，依赖网络状况、服务框架及具体service的质量。 </li>
<li>分布式数据一致性和分布式事务支持困难，一般通过最终一致性简化解决。<br>端到端的测试和排障复杂，<strong>SOA</strong>对运维提出更高要求。<br>例子如下：</li>
</ul>
<p><img src="/images/fuwu/06.png" alt="image"></p>
<ul>
<li><strong>SOA的特点</strong>  </li>
</ul>
<ul>
<li>可从企业外部访问</li>
<li>随时可用</li>
<li>粗粒度的服务接口分级</li>
<li>松散耦合</li>
<li>可重用的服务</li>
<li>服务接口设计管理</li>
<li>标准化的服务接口</li>
<li>支持各种消息模式</li>
<li><p>精确定义的服务契约<br>说起SOA 我第一想到的是<strong>企业服务总线（ESB）</strong>     </p>
<h4 id="SOA的好处"><a href="#SOA的好处" class="headerlink" title="SOA的好处"></a><strong>SOA的好处</strong></h4><p><strong>那么SOA有哪些好处呢？</strong></p>
</li>
<li><p>架构上系统更加清晰</p>
</li>
<li>核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险</li>
<li>开发管理方便</li>
<li>单独团队维护、工作分明，职责清晰</li>
<li>业务复用、代码复用</li>
<li>非常容易拓展</li>
<li><strong>SOA</strong>实现方式</li>
</ul>
<p>如果要实现SOA的话，最常用的方式就是利用<strong>RPC</strong>框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC<strong>远程服务调用</strong>。类似于<strong>RPC</strong>方案有很多，比如：</p>
<ul>
<li><strong>Java RMI</strong></li>
<li><strong>WebService</strong></li>
<li><strong>Hessian</strong></li>
<li><strong>Thrift</strong></li>
<li>… </li>
<li>…   </li>
</ul>
<h3 id="服务化面临的挑战"><a href="#服务化面临的挑战" class="headerlink" title="服务化面临的挑战"></a>服务化面临的挑战</h3><p><strong>上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。</strong></p>
<ul>
<li>服务越来越多，配置管理复杂</li>
<li>服务间依赖关系复杂</li>
<li>服务之间的负载均衡</li>
<li>服务的拓展</li>
<li>服务监控</li>
<li>服务降级</li>
<li>服务鉴权</li>
<li>服务上线与下线</li>
<li>服务文档</li>
<li>… </li>
<li>…<br><strong>有时间我专门有写一篇关于RPC的文章</strong><br>我们接着往下说，有了服务  就需要治理跟维护  下面我们讲一讲服务治理</li>
</ul>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>上面提到了服务化，其实要想服务化，服务治理是关键。那么有没有好的服务治理方案呢？答案是有的，而且还很多，比如：   <strong>ICE</strong> <strong>dubbo</strong> <strong>springcloud</strong> <strong>魔毯</strong> 等等<br>下面我们简单说说服务治理所需要的</p>
<ul>
<li>集中的注册中心和存储库，以查找和发布与服务相关的构件和元数据。</li>
<li>查找正确的授权服务。</li>
<li>避免重复工作。</li>
<li>促进重用。</li>
<li>确定服务在 <strong>SOA</strong> 生命周期中的当前状态。</li>
<li>为服务订阅者提供可见性。</li>
<li>确定相关服务和更改某个服务所造成的影响。</li>
<li>传达对服务所做的更改。</li>
<li>用于联系和强制应用于某个服务的策略的机制。策略通过使用治理框架来定义。</li>
<li>具有生命周期感知性的可自定义系统，该系统在生命周期中发生阶段更改时触发验证，以便能够自动化逐个阶段的治理验证。</li>
<li>在理想的情况下，注册中心应该针对SOA运行时进行优化，以便能够在运行时期间，使用存储在注册中心的元数据来通过动态路由充实内容。<br><strong>详细的各个中间件的原理以及怎么解决服务治理的我有专门写文章</strong><br>继续往下说 从去年微服务突然火了起来，咱们看看微服务   <h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2></li>
</ul>
<p>在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。</p>
<p>微服务有两个核心：</p>
<ul>
<li><strong>微：服务的粒度要细，即服务要细化到API(要做到这一点很不容易，比如服务的切分)</strong>   </li>
<li><strong>服务：提供好服务，要让用户感到好用</strong>   </li>
</ul>
<p>上面两个核心总结起来，可以用下面这幅图表示：<br><img src="/images/fuwu/07.png" alt="image">   </p>
<p>从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。</p>
<p>我们可以看到，有了微服务之后，服务对用户来说变得特别简单。不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。<br><img src="/images/fuwu/08.png" alt="image"></p>
<p>说到这里，大家就应该大体知道该怎么做微服务了 其实“云”是最关键的。<br>微服务的关键是服务网关，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。</p>
<h5 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h5><ul>
<li><p>服务需要再细化成API（服务接口——&gt;服务API）</p>
</li>
<li><p>每个服务由一组API组成</p>
</li>
<li>以API形式对外提供统一格式的服务</li>
<li>使用者无需任何配置，直接调用（http）</li>
<li>完整的API文档</li>
<li>API服务安全可靠稳定   </li>
<li><strong>总结：大概是15年8月接触SOA吧以上就是我的粗浅理解，下一篇我会介绍服务治理的几个框架</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期都在大谈微服务，本人也在做相关的工作已经两年左右了，做了一个微服务的分享，整理了这篇文章，有问题可以在下面留言，可以和大家一起讨论。    &lt;/p&gt;
&lt;p&gt;先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸
    
    </summary>
    
      <category term="微服务 SOA  服务治理" scheme="http://91fz.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1-SOA-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="微服务" scheme="http://91fz.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOA" scheme="http://91fz.org/tags/SOA/"/>
    
      <category term="服务治理" scheme="http://91fz.org/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin初探 集成springMvc</title>
    <link href="http://91fz.org/2017/06/01/kotlindemo/"/>
    <id>http://91fz.org/2017/06/01/kotlindemo/</id>
    <published>2017-05-31T16:00:00.000Z</published>
    <updated>2017-07-01T15:44:25.127Z</updated>
    
    <content type="html"><![CDATA[<p>自从Google I/O 大会上宣布 Kotlin 成为 Android 开发的官方语言，Kotlin 就吸引了很多人的目光，反正在家休息、研究了下，<br>整理成这篇博客来简单介绍下Kotlin。</p>
<h2 id="Kotlin的起源"><a href="#Kotlin的起源" class="headerlink" title="Kotlin的起源"></a><strong>Kotlin的起源</strong></h2><p>Kotlin是一个基于JVM的新的编程语言，由JetBrains开发。JetBrains，作为目前广受欢迎的Java IDE IntelliJ的提供商，在Apache许可下已经开源其Kotlin编程语言。与Java相比，Kotlin的语法更简洁、更具表达性，而且提供了更多的特性，比如，<strong>高阶函数</strong>、<strong>操作符重载</strong>、<strong>字符串模板</strong>。<strong>它与Java高度可互操作</strong>，而且还可以同时用在一个项目中。</p>
<h2 id="Kotlin与Java语言上的比较"><a href="#Kotlin与Java语言上的比较" class="headerlink" title="Kotlin与Java语言上的比较"></a>Kotlin与Java语言上的比较</h2><ul>
<li>函数式的：<strong>Kotlin</strong>是基于面向对象的语言。使用了很多函数式编程的概念，比如，<strong>使用lambda表达式来更方便地解决问题</strong>。其中一个很棒的特性就是<strong>Collections</strong>的处理方式。<strong>但是java 在8中也支持函数式编程，lamda表达式这些当然也不在话下了。</strong></li>
<li><strong>可以扩展函数</strong>：意味着我们可以扩展类的更多的特性，甚至我们没有权限去访问这个类中的代码。<br>例如，<strong>以下代码可以更简单的使用Toast</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun Activity.toast(message: CharSequence, duration: Int =  oast.LENGTH_SHORT)&#123;</div><div class="line">   Toast.makeText(this, message, duration).show()</div><div class="line">&#125;</div><div class="line"></div><div class="line">  Activity：表示函数的接收者，也就是函数扩展的对象</div><div class="line">  . ：扩展函数修饰符</div><div class="line">  toast：扩展函数的名称</div><div class="line">  (...)：扩展函数的参数，可以为null</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>高度互操作性的</strong>：可以继续使用所Java写的代码和库，因为两个语言之间的互操作性是完美的。甚至可以在项目中使用<strong>Kotlin</strong>和<strong>Java</strong>混合编程<br><img src="/images/kotlin/kotlin.png" alt="image">  </p>
<p>如上图，我们可以轻松的使用 Intellij IDEA 自带的代码转换把Java代码转换为Kotlin代码<br>Kotlin 的文件是 .kt 结尾，向 .kt 文件中粘贴 <strong>Java</strong> 代码时都能自动转化为 Kotlin 代码，这点让我想到了当初搞<strong>ZeroC-ice</strong>的ICE的中间语言slice，不过slice能可以根据你的需求翻译成各种常见的语言，不过数据类型转换却比较难（这不是本次的重点）。</p>
</li>
<li><p><strong>更加易表现</strong>：Kotlin最重要的优点之一。开发相同功能你可以少写很多的代码。<br>以下这个类是一个很常见的Java类，但是使用Kotlin可以节省很多代码量。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">    private String name;//姓名</div><div class="line">    private int age;//年龄</div><div class="line">    private String hobby;//爱好</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getAge() &#123;</div><div class="line">        return age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAge(int age) &#123;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getHobby() &#123;</div><div class="line">        return hobby;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setHobby(String hobby) &#123;</div><div class="line">        this.hobby = hobby;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Kotlin达到同样的效果只需要一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Student(var name: String, var age: Int, var hobby: String)</div></pre></td></tr></table></figure>
<ul>
<li><strong>更加安全</strong>：<strong>Kotlin</strong>是空安全的，就是说在编译时期就处理了各种<strong>null</strong>的情况，避免了执行时异常。如果一个对象可以是<strong>null</strong>，则我们需要明确地指定它，然后在使之前检查是否是null。可以节约很多调试<strong>空指针</strong>的时间并解决相应的bug。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//普通的 String 类型的变量不能为空</div><div class="line">var str: String =&quot;abc&quot;</div><div class="line">str = null //编译错误</div><div class="line"></div><div class="line">-------------------------</div><div class="line"></div><div class="line">//允许为空，我们必须把它声明为可空的变量：</div><div class="line">var b: String? = &quot;abc&quot;</div><div class="line">b = null</div></pre></td></tr></table></figure>
<h2 id="使用Kotlin整合springMvc写了一个-web项目的demo"><a href="#使用Kotlin整合springMvc写了一个-web项目的demo" class="headerlink" title="使用Kotlin整合springMvc写了一个 web项目的demo"></a>使用Kotlin整合springMvc写了一个 web项目的demo</h2><ul>
<li>首先安装<strong>Kotlin</strong>的插件<br><img src="/images/kotlin/kotlin01.png" alt="image"><br>首先创建一个 <strong>Kotlin</strong> 项目，然后添加 <strong>Maven</strong> 组件<br><img src="/images/kotlin/kotlin02.png" alt="image"><br><img src="/images/kotlin/kotlin03.png" alt="image">   </li>
<li><strong>完成后项目结构如下</strong><br><img src="/images/kotlin/kotlin04.png" alt="image"><br>pom文件如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</div><div class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</div><div class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class="line"></div><div class="line">  &lt;groupId&gt;kotlin&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;demo&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">  &lt;build&gt;</div><div class="line">    &lt;plugins&gt;</div><div class="line">      &lt;plugin&gt;</div><div class="line">        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;</div><div class="line">        &lt;executions&gt;</div><div class="line">          &lt;execution&gt;</div><div class="line">            &lt;id&gt;compile&lt;/id&gt;</div><div class="line">            &lt;phase&gt;process-sources&lt;/phase&gt;</div><div class="line">            &lt;goals&gt;</div><div class="line">              &lt;goal&gt;compile&lt;/goal&gt;</div><div class="line">            &lt;/goals&gt;</div><div class="line">            &lt;configuration&gt;</div><div class="line">              &lt;sourceDirs&gt;</div><div class="line">                &lt;source&gt;src/main/java&lt;/source&gt;</div><div class="line">              &lt;/sourceDirs&gt;</div><div class="line">            &lt;/configuration&gt;</div><div class="line">          &lt;/execution&gt;</div><div class="line">          &lt;execution&gt;</div><div class="line">            &lt;id&gt;test-compile&lt;/id&gt;</div><div class="line">            &lt;phase&gt;process-test-sources&lt;/phase&gt;</div><div class="line">            &lt;goals&gt;</div><div class="line">              &lt;goal&gt;test-compile&lt;/goal&gt;</div><div class="line">            &lt;/goals&gt;</div><div class="line">            &lt;configuration&gt;</div><div class="line">              &lt;sourceDirs&gt;&lt;/sourceDirs&gt;</div><div class="line">            &lt;/configuration&gt;</div><div class="line">          &lt;/execution&gt;</div><div class="line">        &lt;/executions&gt;</div><div class="line">      &lt;/plugin&gt;</div><div class="line">    &lt;/plugins&gt;</div><div class="line">  &lt;/build&gt;</div><div class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</div><div class="line"></div><div class="line">  &lt;properties&gt;</div><div class="line">    &lt;kotlin.version&gt;1.1.2-4&lt;/kotlin.version&gt;</div><div class="line">    &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;</div><div class="line">    &lt;jackson.version&gt;2.7.3&lt;/jackson.version&gt;</div><div class="line">  &lt;/properties&gt;</div><div class="line">  &lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">      &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line"></div><div class="line">    &lt;!-- spring依赖 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line"></div><div class="line">    &lt;!-- jackson作为controller层的json转换器 --&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;</div><div class="line">      &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;</div><div class="line">      &lt;version&gt;$&#123;kotlin.version&#125;&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">  &lt;/dependencies&gt;</div><div class="line">&lt;/project&gt;</div></pre></td></tr></table></figure>
<p>spring.xml 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</div><div class="line">    &lt;context:component-scan base-package=&quot;com.timothy.web&quot;&gt;</div><div class="line">        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt;</div><div class="line">    &lt;/context:component-scan&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>springmvc.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</div><div class="line">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</div><div class="line">                        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt;</div><div class="line">    &lt;context:component-scan base-package=&quot;com.timothy.web.controller&quot; /&gt;</div><div class="line">    &lt;mvc:default-servlet-handler /&gt;</div><div class="line">    &lt;mvc:annotation-driven&gt;</div><div class="line">        &lt;!-- json转换器 --&gt;</div><div class="line">        &lt;mvc:message-converters&gt;</div><div class="line">            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</div><div class="line">                &lt;property name=&quot;supportedMediaTypes&quot;&gt;</div><div class="line">                    &lt;list&gt;</div><div class="line">                        &lt;value&gt;application/json&lt;/value&gt;</div><div class="line">                        &lt;value&gt;text/json&lt;/value&gt;</div><div class="line">                    &lt;/list&gt;</div><div class="line">                &lt;/property&gt;</div><div class="line">            &lt;/bean&gt;</div><div class="line">        &lt;/mvc:message-converters&gt;</div><div class="line">    &lt;/mvc:annotation-driven&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<ol>
<li>接下来做一个简单的 <strong>Controller</strong> 示例<br><strong>KotlinController的代码如下所示：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.timothy.web.controller</div><div class="line">import com.timothy.web.pojo.Person</div><div class="line">import com.timothy.web.service.KotlinService</div><div class="line">import org.springframework.beans.factory.annotation.Autowired</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping</div><div class="line"></div><div class="line">import org.springframework.web.bind.annotation.RestController</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by timothy on 2017/6/1.</div><div class="line"> */</div><div class="line">@RestController</div><div class="line">class KotlinController &#123;</div><div class="line">    @Autowired</div><div class="line">    private var kotlinService: KotlinService? = null</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private var person: Person? = null</div><div class="line"></div><div class="line">    @RequestMapping(&quot;/kotlin&quot;)</div><div class="line">    fun home() = mapOf(&quot;kotlin&quot; to kotlinService?.kotlin(), &quot;map&quot; to kotlinService?.map(), &quot;person&quot; to person)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>KotlinService代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.timothy.web.service</div><div class="line"></div><div class="line">import org.springframework.stereotype.Service</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by timothy on 2017/6/1.</div><div class="line"> */</div><div class="line">@Service</div><div class="line">class KotlinService &#123;</div><div class="line">    fun kotlin() = &quot;kotlin&quot;</div><div class="line"></div><div class="line">    fun map() = mapOf(&quot;one&quot; to 1, &quot;two&quot; to 2, &quot;three&quot; to 3)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>bean代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">package com.timothy.web.pojo</div><div class="line"></div><div class="line">import org.springframework.stereotype.Component</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by timothy on 2017/6/1.</div><div class="line"> */</div><div class="line">@Component</div><div class="line">data internal class Person(var name: String? = &quot;timothy&quot;, var id: Int? = 1)</div></pre></td></tr></table></figure>
<p>效果如下：<br><img src="/images/kotlin/kotlin05.png" alt="image">    </p>
<h2 id="总结：可以看出，Kotlin-代替-Java-开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的-的经典框架。同时，Kotlin-的一些新特性也让代码的简洁性和易读性有了一定程度的提高"><a href="#总结：可以看出，Kotlin-代替-Java-开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的-的经典框架。同时，Kotlin-的一些新特性也让代码的简洁性和易读性有了一定程度的提高" class="headerlink" title="总结：可以看出，Kotlin 代替 Java 开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的 的经典框架。同时，Kotlin 的一些新特性也让代码的简洁性和易读性有了一定程度的提高"></a>总结：<strong>可以看出，</strong>Kotlin<strong> 代替 </strong>Java<strong> 开发后端也对简单，在熟悉语法之后就可以上手，而且kotlin也兼容java的 的经典框架。同时，Kotlin 的一些新特性也让代码的简洁性和易读性有了一定程度的提高</strong></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从Google I/O 大会上宣布 Kotlin 成为 Android 开发的官方语言，Kotlin 就吸引了很多人的目光，反正在家休息、研究了下，&lt;br&gt;整理成这篇博客来简单介绍下Kotlin。&lt;/p&gt;
&lt;h2 id=&quot;Kotlin的起源&quot;&gt;&lt;a href=&quot;#Kotl
    
    </summary>
    
      <category term="Kotlin" scheme="http://91fz.org/categories/Kotlin/"/>
    
    
      <category term="kotlin" scheme="http://91fz.org/tags/kotlin/"/>
    
      <category term="springmvc" scheme="http://91fz.org/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>阿里云部署 Web 环境（LAMP）</title>
    <link href="http://91fz.org/2016/10/19/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2lamp/"/>
    <id>http://91fz.org/2016/10/19/阿里云部署lamp/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2017-07-01T16:16:22.406Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这里给大家介绍如何使用阿里云镜像，一键部署 Web 环境，包括安装 Nginx、MySQL、phpwind 和 phpMyAdmin。</strong><br>软件包中包含的软件及版本如下：<br><strong>nginx</strong>：1.4.4<br><strong>apache</strong>：2.2.29、2.4.10<br><strong>mysql</strong>：5.1.73、5.5.40、5.6.21<br><strong>php</strong>：5.2.17、5.3.29、5.4.23、5.5.7<br><strong>php 扩展</strong>：memcache、Zend Engine/OPcache<br><strong>jdk</strong>：1.7.0<br><strong>tomcat</strong>：7.0.54<br><strong>ftp</strong>：（yum/apt-get 安装）<br><strong>phpwind</strong>：8.7 GBK<br><strong>phpmyadmin</strong>：4.1.8   </p>
<h2 id="说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。"><a href="#说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。" class="headerlink" title="说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。   "></a><strong>说明：这是写文档时参考的软件版本。您下载的版本可能与此不同。</strong>   </h2><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>部署之前，请确保：</li>
<li>您的实例可以连接公网。</li>
<li>已经安装用于连接 Linux 实例的工具，如 <a href="http://www.netsarang.com/products/xsh_overview.html/" target="_blank" rel="external">Xshell</a> 和 <a href="http://www.netsarang.com/products/xfp_overview.html" target="_blank" rel="external">Xftp</a>。本文将以这两个工具为例介绍操作步骤。</li>
<li><strong>注意</strong>：阿里云 <strong>Linux</strong> 一键安装 Web 环境安装包暂不支持自动挂载 I/O 优化的数据盘。</li>
</ul>
<hr>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>在浏览器中打开阿里云的云市场。<br>搜索 阿里云<strong>linux</strong>一键安装<strong>web</strong>环境，然后购买该软件。<br>登录云服务器管理控制台。打开 <strong>产品与服务</strong>&gt; <strong>云市场</strong>。<br>单击 <strong>已购买的服务</strong>。在 <strong>阿里云Linux一键安装Web环境</strong>的右侧，单击 <strong>管理</strong>。<br>点击 <strong>下载地址</strong>，一键下载<strong>安装包</strong>。<br>解压缩安装包。文件夹名称为<strong>sh-1.5.5</strong>。<br><strong>说明</strong>：这是写文档时参考的文件夹名称，您下载的版本可能与此不同。<br>确保您安装了连接 Linux 实例的工具，如 Xshell 和 Xftp。<br>打开 Xshell，设置登录实例所需的信息。<br>设置连接名称。<br>协议选择 <strong>SSH</strong>。<br>输入主机公网 IP 地址。<br>端口号填 <strong>22</strong>。<br>然后单击 确定 <strong>保存</strong>。<br><img src="/images/aliyun/Imageali.png" alt="image"><br>单击左侧导航中的 <strong>连接</strong> &gt; <strong>用户身份验证</strong>，验证方法选择 <strong>Password</strong>，然后输入用户名<strong>root</strong> 和<strong>登录密码</strong>。<br><img src="/images/aliyun/Imageali01.png" alt="image">   </p>
<p>单击 <strong>Xshell </strong>工具栏的<strong> Xftp </strong>图标 （新建文件传输），或使用快捷键<strong> CTRL + ALT + F</strong> 打开<strong>Xftp</strong>。<br><img src="/images/aliyun/Imageali02.png" alt="image"><br>然后通过 <strong>Xftp</strong> 上传一键安装包文件，直接按住左侧的本地安装文件夹，拖放到右侧 <strong>Linux</strong> 实例的目录下。<br><img src="/images/aliyun/Imageali03.png" alt="image"><br>回到 <strong>Xshell</strong> 的链接界面，依次键入以下安装命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chmod -R 777 sh-1.5.5</div><div class="line">cd sh-1.5.5</div><div class="line">./install.sh</div></pre></td></tr></table></figure>
<p><img src="/images/aliyun/Imageali04.png" alt="image">  </p>
<p>安装完成后执行 <strong>cat</strong> <strong>account.log </strong>命令，可以查看 <strong>account.log</strong> 文件，数据库密码在里面.   根据需要选择    1 (<strong>nginx</strong>) 或者 2 (<strong>apache</strong>)。<br>如直接回车，或输入错误字符，则默认选择 <strong>nginx</strong>。在示例中，此处选择 2。<br>注意：如果要使用 Java 环境（安装 <strong>tomcat+JDK</strong>），必须选择 nginx 服务器。<br>依次选择要安装的 <strong>nginx</strong> 或 <strong>Apache</strong> 版本、<strong>PHP</strong> 版本、<strong>MySQL</strong> 版本。<strong>nginx</strong> 和 <strong>PHP</strong> 建议选择最新的版本。<br><strong>注意</strong>：<strong>MySQL</strong> 建议选择 <strong>5.5.40</strong>，不要选择最新版本，否则可能无法正常使用。</p>
<p><img src="/images/aliyun/Imageali05.png" alt="image">  </p>
<p>输入 <strong>y</strong> 开始安装。一般需要半个小时左右安装完毕。看到下面这个界面，就表示安装顺利完成了<br><img src="/images/aliyun/Imageali06.png" alt="image">  </p>
<p>检查安装结果，输入下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -tunpl</div></pre></td></tr></table></figure></p>
<p>-端口与服务信息如下：<br>-9000：PHP进程服务。如果安装的是Apache，则没有此端口。<br>-3306：MySQL服务<br>-80：HTTPD 或者 nginx 服务<br>-21：FTP服务<br><img src="/images/aliyun/Imageali07.png" alt="image"><br>输入以下命令，查看默认的 FTP 和 MySQL 的账号信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat account.log</div></pre></td></tr></table></figure></p>
<p>输入该命令后，系统会在屏幕上显示 <strong>FTP</strong> 和 <strong>MySQL</strong> 的用户名和密码。其中 FTP 的用户名是 <strong>www</strong>，MySQL 的用户名是 <strong>root</strong>。<br> <img src="/images/aliyun/Imageali08.png" alt="image"><br> 修改 FTP 密码：用 root 登录，执行下列命令，然后输入您的 FTP 新密码:<br> <img src="/images/aliyun/Imageali18.png" alt="image"><br> 修改 <strong>MySQL</strong> 密码。<br><strong>注意</strong>： <strong>-p 和旧密码之间没有空格</strong>；而 <strong>password</strong> 和新密码之间有空格 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -uroot -p旧密码 password 新密码</div></pre></td></tr></table></figure>
<p>  输入命令 cat /alidata/website-info.log，查看刚才安装软件的版本信息。至此所有配置结束。 </p>
<p> <img src="/images/aliyun/Imageali09.png" alt="image"><br> 安装 phpwind 和 phpMyAdmin。可以通过访问一键安装包默认安装的 phpwind 进行安装。直接在浏览器中输入您的域名或者 IP。如果是第一次访问 phpwind，系统会自动跳转到安装页面。单击 接受 进行安装。   </p>
<p>  <img src="/images/aliyun/Imageali10.png" alt="image"> </p>
<p>  在创建数据页面，单击 下一步。<br>  <img src="/images/aliyun/Imageali11.png" alt="image">    </p>
<p>  选择数据库类型为 MySQL，数据库用户名和密码填写 account.log 中的用户名和刚修改过的密码。然后设置数据库名称、管理员账号和密码等信息。单击 下一步。系统会自动安装。</p>
<p>  <img src="/images/aliyun/Imageali12.png" alt="image"><br>  接下来访问 phpMyAdmin。在浏览器中输入域名，或者 IP/phpmyadmin 路径 （如 <a href="http://127.0.0.1/phpmyadmin" target="_blank" rel="external">http://127.0.0.1/phpmyadmin</a> ），访问 phpMyAdmin。输入 MySQL 用户名和密码，然后单击 执行，即可登录。</p>
<p>  <img src="/images/aliyun/Imageali13.png" alt="image"><br>  从 phpMyAdmin 即可操作 MySQL。可以创建博客使用的数据库。输入数据库名称，然后排序规则选择 utf8_general_ci，单击 创建。<br>    <img src="/images/aliyun/Imageali14.png" alt="image"><br>    恭喜您！您已经成功部署了 Web 环境，可以开始制作和发布自己的站点了。</p>
<h2 id="卸载一键安装包"><a href="#卸载一键安装包" class="headerlink" title="卸载一键安装包"></a><strong>卸载一键安装包</strong></h2><p>如果需要卸载一键安装包，执行下列命令： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chmod 777 -R sh-1.5.5</div><div class="line">cd sh-1.5.5</div><div class="line">./uninstall.sh</div></pre></td></tr></table></figure>
<p><img src="/images/aliyun/Imageali15.png" alt="image"><br><img src="/images/aliyun/Imageali16.png" alt="image"><br><img src="/images/aliyun/Imageali17.png" alt="image"> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这里给大家介绍如何使用阿里云镜像，一键部署 Web 环境，包括安装 Nginx、MySQL、phpwind 和 phpMyAdmin。&lt;/strong&gt;&lt;br&gt;软件包中包含的软件及版本如下：&lt;br&gt;&lt;strong&gt;nginx&lt;/strong&gt;：1.4.4&lt;b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVA8新特性（自己总结）</title>
    <link href="http://91fz.org/2016/05/18/java8/"/>
    <id>http://91fz.org/2016/05/18/java8/</id>
    <published>2016-05-17T16:00:00.000Z</published>
    <updated>2017-07-03T12:18:52.290Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言：用java8有段时间了整理了下java8的新特性。在项目里，领导不让我们用 应为要部署给企业跟政府考虑到兼容，所以只能自己业余时间玩玩。<br>下面就是我整理的一些</strong></p>
<h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a>一、接口的默认方法</h2><p><strong>Java 8</strong>允许我们给接口添加一个非抽象的方法实现，只需要使用 <strong>default</strong>关键字即可，这个特征又叫做扩展方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">interface Formula &#123;</div><div class="line">    double calculate(int a);</div><div class="line"></div><div class="line">    default double sqrt(int a) &#123;</div><div class="line">        return Math.sqrt(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Formula接口在拥有<strong>calculate</strong>方法之外同时还定义了<strong>sqrt</strong>方法，实现了<strong>Formula</strong>接口的子类只需要实现一个<strong>calculate</strong>方法，默认方法<strong>sqrt</strong>将在子类上可以直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Formula formula = new Formula() &#123;</div><div class="line">    @Override</div><div class="line">    public double calculate(int a) &#123;</div><div class="line">        return sqrt(a * 100);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">formula.calculate(100);     // 100.0</div><div class="line">formula.sqrt(16);           // 4.0</div></pre></td></tr></table></figure></p>
<p><strong>formula</strong>被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 <strong>sqrt(a * 100)</strong>。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p>
<p> <strong>在JAVA中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</strong></p>
<h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p>首先看看在老版本的Java中是如何排列字符串的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</div><div class="line"></div><div class="line">Collections.sort(names, new Comparator&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public int compare(String a, String b) &#123;</div><div class="line">        return b.compareTo(a);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>只需要给静态方法<strong>Collections.sort</strong> 传入一个<strong>List</strong>对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给<strong>sort</strong>方法。</p>
<p>在<strong>Java 8 </strong>中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，<strong>lambda</strong>表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">    return b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure></p>
<p>对于函数体只有一行代码的，你可以去掉大括号<strong>{}</strong>以及<strong>return</strong>关键字，但是你还可以写得更短点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>
<p><strong>Java编译器可以自动推导出参数类型</strong>，所以你可以不用再写一次类型。接下来我们看看<strong>lambda</strong>表达式还能作出什么更方便的东西来：</p>
<h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p><strong>Lambda</strong>表达式是如何在<strong>java</strong>的类型系统中表示的呢？每一个<strong>lambda</strong>表达式都对应一个类型，通常是接口类型。而<strong>“函数式接口”</strong>是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 <strong>@FunctionalInterface</strong> 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@FunctionalInterface</div><div class="line">interface Converter&lt;F, T&gt; &#123;</div><div class="line">    T convert(F from);</div><div class="line">&#125;</div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);    // 123</div></pre></td></tr></table></figure></p>
<p><strong>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的</strong>。   </p>
<p><strong>将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener</strong></p>
<h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a>四、方法与构造函数引用</h2><p>前一节中的代码还可以通过静态方法引用来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(&quot;123&quot;);</div><div class="line">System.out.println(converted);   // 123</div></pre></td></tr></table></figure>
<p><strong>Java 8 允许你使用 :<br>关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">converter = something::startsWith;</div><div class="line">String converted = converter.convert(&quot;Java&quot;);</div><div class="line">System.out.println(converted);    // &quot;J&quot;</div></pre></td></tr></table></figure>
<p>接下来看看构造函数是如何使用关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们指定一个用来创建<strong>Person</strong>对象的对象工厂接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</div><div class="line">    P create(String firstName, String lastName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</div><div class="line">Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);</div></pre></td></tr></table></figure></p>
<p>我们只需要使用 <strong>Person new</strong> 来获取<strong>Person</strong>类构造函数的引用，<strong>Java</strong>编译器会自动根据<strong>PersonFactory.create</strong>方法的签名来选择合适的构造函数。</p>
<h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a>五、Lambda 作用域</h2><p>在<strong>lambda</strong>表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a>六、访问局部变量</h2><p>我们可以直接在<strong>lambda</strong>表达式中访问外层的局部变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">final int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure></p>
<p>但是和匿名对象不同的是，这里的变量<strong>num</strong>可以不用声明为<strong>final</strong>，该代码同样正确：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(2);     // 3</div></pre></td></tr></table></figure>
<p>不过这里的<strong>num</strong>必须不可被后面的代码修改（即隐性的具有<strong>final</strong>的语义），例如下面的就无法编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int num = 1;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = 3;</div></pre></td></tr></table></figure>
<p>在lambda表达式中试图修改num同样是不允许的。</p>
<h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p>和本地变量不同的是，<strong>lambda</strong>内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Lambda4 &#123;</div><div class="line">    static int outerStaticNum;</div><div class="line">    int outerNum;</div><div class="line"></div><div class="line">    void testScopes() &#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = 23;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = 72;</div><div class="line">            return String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p>还记得第一节中的<strong>formula</strong>例子么，接口<strong>Formula</strong>定义了一个默认方法<strong>sqrt</strong>可以直接<strong>被formula</strong>的实例包括匿名对象访问到，但是在<strong>lambda</strong>表达式中这个是不行的。<br><strong>Lambda</strong>表达式中是无法访问到默认方法的，以下代码将无法编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt( a * 100);</div><div class="line">Built-in Functional Interfaces</div></pre></td></tr></table></figure>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如<em>Comparator</em>或者<strong>Runnable</strong>接口，这些接口都增加了<strong>@FunctionalInterface</strong>注解以便能用在<strong>lambda</strong>上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自<strong>Google Guava</strong>库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到<strong>lambda</strong>上使用的。</p>
<ul>
<li><strong>Predicate接口</strong></li>
</ul>
<p><strong>Predicate</strong> 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</div><div class="line"></div><div class="line">predicate.test(&quot;foo&quot;);              // true</div><div class="line">predicate.negate().test(&quot;foo&quot;);     // false</div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
<ul>
<li><strong>Function接口</strong></li>
</ul>
<p><strong>Function </strong>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（<strong>compose, andThen</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</div></pre></td></tr></table></figure>
<ul>
<li><strong>Supplier 接口</strong></li>
</ul>
<p><strong>Supplier</strong> 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</div><div class="line">personSupplier.get();   // new Person</div></pre></td></tr></table></figure>
<ul>
<li><strong>Consumer 接口</strong></li>
</ul>
<p><strong>Consumer</strong> 接口表示执行在单个参数上的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);</div><div class="line">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</div></pre></td></tr></table></figure>
<p><strong>Comparator 接口</strong></p>
<p><strong>Comparator</strong> 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</div><div class="line">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             // &gt; 0</div><div class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</div></pre></td></tr></table></figure>
<ul>
<li><strong>Optional 接口</strong></li>
</ul>
<p><strong>Optional</strong> 不是函数是接口，这是个用来防止<strong>NullPointerException</strong>异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p>
<p><strong>Optional</strong> 被定义为一个简单的容器，其值可能是<strong>null</strong>或者不是<strong>null</strong>。在<strong>Java 8</strong>之前一般某个函数应该返回非空对象但是偶尔却可能返回了<strong>null</strong>，而在<strong>Java 8</strong>中，不推荐你返回<strong>null</strong>而是返回<strong>Optional</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</div><div class="line"></div><div class="line">optional.isPresent();           // true</div><div class="line">optional.get();                 // &quot;bam&quot;</div><div class="line">optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</div></pre></td></tr></table></figure>
<p><strong>Stream 接口</strong></p>
<p><strong>java.util.Stream</strong>表示能应用在一组元素上一次执行的操作序列。<strong>Stream</strong> 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回<strong>Stream</strong>本身，这样你就可以将多个操作依次串起来。<strong>Stream</strong> 的创建需要指定一个数据源，比如 <strong>java.util.Collection</strong>的子类，<strong>List</strong>或者<strong>Set</strong>， <strong>Map</strong>不支持。<strong>Stream</strong>的操作可以串行执行或者并行执行。</p>
<p>首先看看<strong>Stream</strong>是怎么用，首先创建实例代码的用到的数据<strong>List</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(&quot;ddd2&quot;);</div><div class="line">stringCollection.add(&quot;aaa2&quot;);</div><div class="line">stringCollection.add(&quot;bbb1&quot;);</div><div class="line">stringCollection.add(&quot;aaa1&quot;);</div><div class="line">stringCollection.add(&quot;bbb3&quot;);</div><div class="line">stringCollection.add(&quot;ccc&quot;);</div><div class="line">stringCollection.add(&quot;bbb2&quot;);</div><div class="line">stringCollection.add(&quot;ddd1&quot;);</div></pre></td></tr></table></figure>
<p><strong>以上就是我自己研究的一些。还有很多  灯油机会在补充吧。。每天 加班  。。。。。。。。。好累。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言：用java8有段时间了整理了下java8的新特性。在项目里，领导不让我们用 应为要部署给企业跟政府考虑到兼容，所以只能自己业余时间玩玩。&lt;br&gt;下面就是我整理的一些&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、接口的默认方法&quot;&gt;&lt;a href=&quot;#一
    
    </summary>
    
      <category term="JAVA" scheme="http://91fz.org/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://91fz.org/tags/JAVA/"/>
    
      <category term="JAVA新特性" scheme="http://91fz.org/tags/JAVA%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="JAVA8" scheme="http://91fz.org/tags/JAVA8/"/>
    
  </entry>
  
  <entry>
    <title>服务治理框架之DUBBO</title>
    <link href="http://91fz.org/2016/03/21/dubboone/"/>
    <id>http://91fz.org/2016/03/21/dubboone/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2017-07-01T16:12:59.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是dubbo？"><a href="#什么是dubbo？" class="headerlink" title="什么是dubbo？"></a>什么是dubbo？</h2><p><strong>Dubbo</strong>是阿里巴巴开源的分布式服务框架，它是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（<strong>Provider</strong>）和服务消费方（<strong>Consumer</strong>）两个角色。关<strong>于注册中心</strong>、<strong>协议支持</strong>、<strong>服务监控</strong>等内容，但遗憾的的是现在已经停止更新了。由当当网进行维护，<strong>升级为dubbox</strong>，<strong>支持了rest</strong>。<strong>更新了spring等</strong>，<strong>而在阿里内部则又HSF框架代替</strong>。</p>
<h2 id="Dubbo的总体架构"><a href="#Dubbo的总体架构" class="headerlink" title="Dubbo的总体架构"></a>Dubbo的总体架构</h2><p><img src="/images/dubbo/01.png" alt="image"><br><strong>Dubbo框架设计一共划分了10个层</strong>，而最上面的<strong>Service</strong>层是留给实际想要使用<strong>Dubbo</strong>开发分布式服务的开发者实现业务逻辑的接口层。图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，     位于中轴线上的为双方都用到的接口。<br>下面，结合<strong>Dubbo官方文档</strong>，我们分别理解一下框架分层架构中，各个层次的设计要点：</p>
<ul>
<li><p><strong>服务接口层（Service</strong>）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。   </p>
</li>
<li><p><strong>配置层（Config</strong>）：对外配置接口，以<strong>ServiceConfig</strong>和<strong>ReferenceConfig</strong>为中心，可以直接<strong>new</strong>配置类，也可以通过<strong>spring</strong>解析配置生成配置类。   </p>
</li>
<li><p><strong>服务代理层（Proxy）</strong>：服务接口透明代理，生成服务的客户端<strong>Stub</strong>和服务器端<strong>Skeleton</strong>，以<strong>ServiceProxy</strong>为中心，扩展接口为<strong>ProxyFactory</strong>。   </p>
</li>
<li><p><strong>服务注册层（Registry</strong>）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为<strong>RegistryFactory、Registry</strong>和<strong>RegistryService</strong>。可能没有服务注册中心，此时服务提供方直接暴露服务。   </p>
</li>
<li><p><strong>集群层（Cluster）</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以<strong>Invoker</strong>为中心，<strong>扩展接口为Cluster</strong>、<strong>Directory</strong>、<strong>Router和LoadBalance</strong>。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</p>
</li>
<li><p><strong>监控层（Monitor</strong>）：RPC调用次数和调用时间监控，<strong>以Statistics为中心</strong>，扩展接口为MonitorFactory、<strong>Monitor和MonitorService</strong>。   </p>
</li>
<li><p><strong>远程调用层（Protocol）</strong>：封将RPC调用，以<strong>Invocation</strong>和<strong>Result</strong>为中心，扩展接口为<strong>Protocol</strong>、<strong>Invoker</strong>和<strong>Exporter</strong>。<strong>Protocol</strong>是服务域，它是<strong>Invoker</strong>暴露和引用的主功能入口，它负责<strong>Invoker</strong>的生命周期管理。<strong>Invoker</strong>是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起<strong>invoke</strong>调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。   </p>
</li>
<li><p><strong>信息交换层（</strong>Exchange<strong>**）：封装请求响应模式，同步转异步，以</strong>Request<strong>和</strong>Response<strong>为中心，扩展接口为</strong>Exchanger、ExchangeChannel、ExchangeClient<strong>和</strong>ExchangeServer**。</p>
</li>
<li><strong>网络传输层（Transport</strong>）：抽象<strong>mina</strong>和<strong>netty</strong>为统一接口，以<strong>Message</strong>为中心，扩展接口为<strong>Channel</strong>、<strong>Transporter、Client、Server和Codec</strong>。</li>
<li><p><strong>数据序列化层（Serialize）</strong>：可复用的一些工具，扩展接口为 <strong>Serialization、 ObjectInput、ObjectOutput</strong>和 <strong>ThreadPool</strong>。</p>
<p><strong>从上图可以看出，</strong>Dubbo<strong>对于服务提供方和服务消费方，从框架的10层中分别提供了各自需要关心和扩展的接口，构建整个服务生态系统（服务提供方和服务消费方本身就是一个以服务为中心的）。</strong></p>
</li>
</ul>
<p>根据官方提供的，对于上述各层之间关系的描述，如下所示：    </p>
<ul>
<li><p>在RPC中，Protocol是核心层，也就是只要有<strong>Protocol</strong> + <strong>Invoker </strong>+ <strong>Exporter</strong>就可以完成非透明的RPC调用，然后在<strong>Invoker</strong>的主过程上<strong>Filter</strong>拦截点。   </p>
</li>
<li><p>图中的<strong>Consumer</strong>和<strong>Provider</strong>是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用<strong>Client</strong>和<strong>Server</strong>的原因是<strong>Dubbo</strong>在很多场景下都使用<strong>Provider</strong>、<strong>Consumer</strong>、<strong>Registry</strong>、<strong>Monitor</strong>划分逻辑拓普节点，保持统一概念。<br>而<strong>Cluster</strong>是外围概念，所以<strong>Cluster</strong>的目的是将多个<strong>Invoker</strong>伪装成一个<strong>Invoker</strong>，这样其它人只要关注<strong>Protocol</strong>层<strong>Invoker</strong>即可，加上<strong>Cluster</strong>或者去掉<strong>Cluster</strong>对其它层都不会造成影响，因为只有一个提供者时，是不需要<strong>Cluster</strong>的。   </p>
</li>
<li><p><strong>Proxy</strong>层封装了所有接口的透明化代理，而在其它层都以<strong>Invoker</strong>为中心，只有到了暴露给用户使用时，才用<strong>Proxy</strong>将<strong>Invoker</strong>转成接口，或将接口实现转成<strong>Invoker</strong>，也就是去掉<strong>Proxy</strong>层<strong>RPC</strong>是可以Run的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</p>
</li>
<li><p>而<strong>Remoting</strong>实现是<strong>Dubbo</strong>协议的实现，如果你选择<strong>RMI协议</strong>，整个<strong>Remoting</strong>都不会用上，<strong>Remoting</strong>内部再划为<strong>Transport</strong>传输层和<strong>Exchange</strong>信息交换层，Transport层只负责单向消息传输，是对<strong>Mina、Netty、Grizzly</strong>的抽象，它也可以扩展<strong>UDP</strong>传输，而<strong>Exchange</strong>层是在传输层之上封装<strong>了Request-Response</strong>语义。</p>
</li>
<li><strong>Registry</strong>和<strong>Monitor</strong>实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。       <h2 id="DUBBO的特点"><a href="#DUBBO的特点" class="headerlink" title="DUBBO的特点"></a>DUBBO的特点</h2></li>
</ul>
<p>从上面的架构图中，我们可以了解到，<strong>Dubbo</strong>作为一个分布式服务框架，<strong>主要具有如下几个核心的要点：</strong>    </p>
<h3 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h3><p><strong>服务是围绕服务提供方和服务消费方的，服务提供方实现服务，而服务消费方调用服务。</strong>   </p>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><strong>对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。<br>通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。Dubbo提供的注册中心有如下几种类型可供选择：</strong></p>
<ul>
<li>Multicast注册中心</li>
<li>Zookeeper注册中心</li>
<li>Redis注册中心</li>
<li><p>Simple注册中心</p>
<h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p><strong>无论是服务提供方，还是服务消费方，他们都需要对服务调用的实际状态进行有效的监控，从而改进服务质量。</strong></p>
<h3 id="远程通信与信息交换"><a href="#远程通信与信息交换" class="headerlink" title="远程通信与信息交换"></a>远程通信与信息交换</h3><p><strong>远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，还要保证高效、稳定的消息传输。Dubbo继承了当前主流的网络通信框架，主要包括如下几个：</strong></p>
</li>
<li><p>Mina</p>
</li>
<li>Netty</li>
<li>Grizzly<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3>下面从Dubbo官网直接拿来，看一下基于RPC层，服务提供方和服务消费方之间的调用关系，如图所示：    </li>
</ul>
<p><img src="/images/dubbo/02.png" alt="image">    </p>
<p>上图中，蓝色的表示与业务有交互，绿色的表示只对Dubbo内部交互。上述图所描述的调用流程如下：</p>
<ul>
<li>服务提供方发布服务到服务注册中心；</li>
<li>服务消费方从服务注册中心订阅服务；</li>
<li>服务消费方调用已经注册的可用服务</li>
</ul>
<p>接着，将上面抽象的调用流程图展开，详细如图所示：</p>
<p><img src="/images/dubbo/03.png" alt="image">   </p>
<h3 id="注册-注销服务"><a href="#注册-注销服务" class="headerlink" title="注册/注销服务"></a>注册/注销服务</h3><p>服务的注册与注销，是对服务提供方角色而言，那么注册服务与注销服务的时序图，如图所示：</p>
<p><img src="/images/dubbo/04.png" alt="image">   </p>
<h3 id="服务订阅-取消"><a href="#服务订阅-取消" class="headerlink" title="服务订阅/取消"></a>服务订阅/取消</h3><p>为了满足应用系统的需求，服务消费方的可能需要从服务注册中心订阅指定的有服务提供方发布的服务，在得到通知可以使用服务时，就可以直接调用服务。反过来，如果不需要某一个服务了，可以取消该服务。下面看一下对应的时序图，如图所示：</p>
<p><img src="/images/dubbo/05.png" alt="image">    </p>
<h3 id="协议支持"><a href="#协议支持" class="headerlink" title="协议支持"></a>协议支持</h3><p><strong>Dubbo支持多种协议，如下所示：</strong></p>
<ul>
<li>Dubbo协议</li>
<li>Hessian协议</li>
<li>HTTP协议</li>
<li>RMI协议</li>
<li>WebService协议</li>
<li>Thrift协议</li>
<li>Memcached协议</li>
<li>Redis协议<br><strong>在通信过程中，不同的服务等级一般对应着不同的服务质量，那么选择合适的协议便是一件非常重要的事情。你可以根据你应用的创建来选择。例如，使用RMI协议，一般会受到防火墙的限制，所以对于外部与内部进行通信的场景，就不要使用RMI协议，而是基于HTTP协议或者Hessian协议。</strong></li>
</ul>
<h3 id="DUBBO个模块与关系"><a href="#DUBBO个模块与关系" class="headerlink" title="DUBBO个模块与关系"></a><strong>DUBBO个模块与关系</strong></h3><p>Dubbo以包结构来组织各个模块，各个模块及其关系，如图所示：</p>
<p><img src="/images/dubbo/06.png" alt="image">    </p>
<p><strong>可以通过Dubbo的代码（使用Maven管理）组织，与上面的模块进行比较。简单说明各个包的情况</strong></p>
<ul>
<li><p><strong>dubbo-common</strong> <strong>公共逻辑模块</strong>，包括Util类和通用模型。</p>
</li>
<li><p><strong>dubbo-remoting 远程通讯模块</strong>，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。</p>
</li>
<li><p><strong>dubbo-rpc</strong> <strong>远程调用模块</strong>，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</p>
</li>
</ul>
<p>-<strong>dubbo-cluster</strong> <strong>集群模块</strong>，将多个服务提供方伪装为一个提供方，包括：负载均衡、容错、路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发<br>。</p>
<ul>
<li><p><strong>dubbo-registry 注册中心模块</strong>，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</p>
</li>
<li><p><strong>dubbo-monitor</strong> <strong>监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</strong></p>
</li>
<li><strong>dubbo-config</strong> <strong>配置模块</strong>，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。</li>
<li><strong>dubbo-container</strong> <strong>容器模块</strong>，是一个Standalone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。</li>
</ul>
<p><strong>总结：dubbo 是国内应用最广 最受欢迎的服务治理框架，但是很可惜阿里不维护了 ，不过可以使用dubbox，反正据我了解 很多公司还使用dubbo。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是dubbo？&quot;&gt;&lt;a href=&quot;#什么是dubbo？&quot; class=&quot;headerlink&quot; title=&quot;什么是dubbo？&quot;&gt;&lt;/a&gt;什么是dubbo？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Dubbo&lt;/strong&gt;是阿里巴巴开源的分布式服务框架，它是按照
    
    </summary>
    
      <category term="微服务 SOA  服务治理" scheme="http://91fz.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1-SOA-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="微服务" scheme="http://91fz.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SOA" scheme="http://91fz.org/tags/SOA/"/>
    
      <category term="服务治理" scheme="http://91fz.org/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB地理位置索引的实现原理</title>
    <link href="http://91fz.org/2015/08/30/LBS-monggo/"/>
    <id>http://91fz.org/2015/08/30/LBS-monggo/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2017-07-01T16:12:47.722Z</updated>
    
    <content type="html"><![CDATA[<p>地理位置索引支持是<strong>MongoDB</strong>的一大亮点，这也是全球最流行<strong>的LBS服务foursquare 选择MongoDB的原因之一</strong>。<br>我们知道，通常的数据库索引结构是<strong>B+Tree</strong>，怎么样才能将地理位置转化为可建立<strong>B+Tree</strong>的形式呢，下面我会为大家分析下。   </p>
<p><strong>假设我们将需要索引的整个地图分成16×16的方格，如下图（左下角为坐标0,0 右上角为坐标16,16）：</strong><br><img src="/images/monggo/01.png" alt="image">   </p>
<p>单纯的［x，y］的数据是无法建立索引的，所以MongoDB在建立索引的时候，会根据相应字段的坐标计算一个可以用来做索引的hash值，这个值叫做<strong>geohash</strong>，下面我们以地图上坐标为［4，6］的点（图中红叉位置）为例。<br>我们第一步将整个地图分成等大小的四块，如下图：   </p>
<p><img src="/images/monggo/02.png" alt="image"> </p>
<p>划分成四块后我们可以定义这四块的值，如下（左下为00，左上为01，右下为10，右上为11）：<br>01    11<br>00    10<br>这样［4，6］点的geohash值目前为 00<br>然后再将四个小块每一块进行切割，如下：<br><img src="/images/monggo/03.png" alt="image"> </p>
<p>这时［4，6］点位于右上区域，右上的值为11，这样［4，6］点的geohash值变为：0011<br>继续往下做两次切分：<br><img src="/images/monggo/04.png" alt="image"> </p>
<p>最终得到［4，6］点的geohash值为：00110100<br>这样我们用这个值来做索引，则地图上点相近的点就可以转化成有相同前缀的g<strong>eohash</strong>值了。<br>我们可以看到，这个<strong>geohash</strong>值的精确度是与划分地图的次数成正比的，上例对地图划分了四次。而<strong>MongoDB</strong>默认是进行26次划分，这个值在建立索引时是可控的。具体建立二维地理位置索引的命令如下：</p>
<p><img src="/images/monggo/05.png" alt="image"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.map.ensureIndex(&#123;point : &quot;2d&quot;&#125;, &#123;min : 0, max : 16, bits : 4&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地理位置索引支持是&lt;strong&gt;MongoDB&lt;/strong&gt;的一大亮点，这也是全球最流行&lt;strong&gt;的LBS服务foursquare 选择MongoDB的原因之一&lt;/strong&gt;。&lt;br&gt;我们知道，通常的数据库索引结构是&lt;strong&gt;B+Tree&lt;/stron
    
    </summary>
    
      <category term="MonggoDB" scheme="http://91fz.org/categories/MonggoDB/"/>
    
    
      <category term="MonggoDB" scheme="http://91fz.org/tags/MonggoDB/"/>
    
      <category term="NOsql" scheme="http://91fz.org/tags/NOsql/"/>
    
  </entry>
  
  <entry>
    <title>ICE 入门到精通（一）</title>
    <link href="http://91fz.org/2015/08/21/ice/"/>
    <id>http://91fz.org/2015/08/21/ice/</id>
    <published>2015-08-20T16:00:00.000Z</published>
    <updated>2017-07-01T16:13:09.380Z</updated>
    
    <content type="html"><![CDATA[<p>关于ICE的介绍，网上的资料有很多，但是从应用的角度上去使用的并不多，在技术革新的今天我们可能更多的是去关注应用领域而非研究领域，因此根据 我个人的使用经验，想对ICE技术做一些总结和介绍。</p>
<h2 id="什么是ICE"><a href="#什么是ICE" class="headerlink" title="什么是ICE"></a>什么是ICE</h2><p>ICE的全称是 <strong>Internet Communications Engine网络(互联网)通讯引擎</strong><br>它是由Zeroc公司开发的一套开源中间件系统，<strong>与DCOM</strong>,<strong>CORBA</strong>,<strong>WEB SERVICE</strong> <strong>Dcom类似</strong>，<strong>支持RPC</strong>协议，但是在效率上却高于前面所述几种技术方案，是一种适用于各种环境的面向对象的中间件平台：客户和服务器可以用不同的编程语言来编写， 可以运行在不同的操作系统和系统架构上，并且可以使用多种网络技术经行通信（<strong>例如TCP</strong>、<strong>UDP</strong>、<strong>SSL等</strong>），这给我们的应用和部署带来很大的便捷性。</p>
<h2 id="ICE的优点"><a href="#ICE的优点" class="headerlink" title="ICE的优点"></a>ICE的优点</h2><ul>
<li><p>跨平台，支持多种语言</p>
</li>
<li><p>面向对象编程</p>
</li>
<li><p>为分布式应用方面提供了一整套 强大的特性和功能支持（例如负载平衡、软件分发、数据同步等）。</p>
</li>
<li><p>在网络带宽、内存使用和CPU开销方面已经内置了高效的实现。</p>
</li>
<li><p>内置了安全特征的实现，可跨越不安全的网络（广域网）使用。</p>
</li>
<li><p>降低了复杂性，易于学习和使用。</p>
</li>
<li><h2 id="与WebService的对比"><a href="#与WebService的对比" class="headerlink" title="与WebService的对比"></a>与WebService的对比</h2><strong>优点：</strong></li>
<li>1、走TCP或者UDP，效率上和webservice不是一个等级的。</li>
<li>2、安全性方面比webservice要强</li>
<li>3、.ice文件支持对exception的定义</li>
</ul>
<p>缺点：   </p>
<ul>
<li>1、如果提供一个服务在公网上 ， 现在提供wsdl毕竟还是主流，貌似没有人提供.ice文件出去。</li>
<li>2、xml文件个人觉得比.ice文件的可读性更强</li>
</ul>
<h2 id="一些基础的概念和模型"><a href="#一些基础的概念和模型" class="headerlink" title="一些基础的概念和模型"></a>一些基础的概念和模型</h2><p>首先我们来看看ICE的基础调用模型（如下图所示）<br><img src="/images/ice/ice01.png" alt="image"><br><img src="/images/ice/ice02.png" alt="image">  </p>
<p><strong>Client</strong>（客 户端）：估计这个大家都非常清楚，通俗的讲就是一个请求的发起方。</p>
<p><strong>Proxy</strong>（代理）：代理实际上就是远程服务驻在本地的一个代表，创建 它时首先会和远程服务经行握手和状态确认等操作，Client所有的操作都是从过Proxy来办理的。代理又分为直接代理（已经知道服务端的位置及其他信 息）和间接代理（不知道服务器在哪里，由Registry注册器告诉它地址等信息）。</p>
<p><strong>Adapter</strong>（适配器）：是配置相当于服务单位 （Servant）的管理者，它管理着每个请求该分配给哪一个服务单位。</p>
<p><strong>Servant</strong>（服务单元）：它是服务的最小单位，一般是具体到 某个接口的实现。</p>
<p>刚才我们提到了接口的实现，但是这个接口是谁定义的，这个时候我们不免要提到<strong>Slic</strong>e（<strong>Specification</strong> <strong>Language</strong> <strong>for Ice</strong>），也就是ICE所使用的“语言”，正是有了这个“中间语言”，我们才可以做到支持各种编程语言，因为你所使用的语言只要跟<strong>Slice</strong>打交道就可以了,关于Slice我在后面可能会详细的来讲述。</p>
<h2 id="ICE调用模式"><a href="#ICE调用模式" class="headerlink" title="ICE调用模式"></a>ICE调用模式</h2><p><strong>ICE采用的网络协议有TCP、UDP以及SSL三 种，不同于WebService，ICE在调用模式上有好几种选择方案，并且每种方案正对不同的网络协议的特性做了相应的选择</strong>。</p>
<ul>
<li><p><strong>Oneway(单向调用)</strong>：客户端只需将调用注册到本地传输缓冲区（<strong>Local Transport Buffers</strong>）后就立即返回，并不对调用结果负责。</p>
</li>
<li><p><strong>Twoway（双 向调用</strong>）：最通用的模式，同步方法调用模式，只能用TCP或SSL协议。</p>
</li>
<li><p><strong>Datagram（数据报）</strong>：类似于Oneway调用，不同的是 Datagram调用只能采用UDP协议而且只能调用无返回值和无输出参数的方法。</p>
</li>
<li><p><strong>BatchOneway（批量单向调用</strong>）：先将调用存 在调用缓冲区里面，到达一定限额后自动批量发送所有请求（也可手动刷除缓冲区）。</p>
</li>
<li><p><strong>BatchDatagram（批量数据报</strong>）：与上类似。</p>
</li>
</ul>
<p>不同的调用模式其实对应着不动的业务，对于大部分的有返回值的或需要实时响应的方法，我们可能都采用Twoway方式调用，对于一些无需返回值或 者不依赖返回值的业务，我们可以用Oneway或者BatchOneway方式，例如消息通知；剩下的Datagram和<strong>BatchDatagram</strong>方式 一般用在无返回值且不做可靠性检查的业务上，例如日志。</p>
<h2 id="ICE的版本控制（Facet）"><a href="#ICE的版本控制（Facet）" class="headerlink" title="ICE的版本控制（Facet）"></a>ICE的版本控制（Facet）</h2><p>ICE内部集成非常好的版本 控制功能（Facet），在每一个服务单元（Servant）其实都有一个Facet与之并存，如果你没有认为指定，那么这个默认Facet的值就为空 (String.Empty)。在我们业务的实际应用过程中，经常要碰到服务升级的情况，但是升级服务就意味着增大了原有业务调用的稳定性，从而增大了风 险，这个Facet就刚好解决我们遇到的这个难题，我们每次升级都是“新增服务”，而非改变原有业务，新来的业务调用新版本服务，原有业务调用原有版本服 务。当检测一些很“老”的服务确认无人调用的时候我们就可以关掉了。</p>
<p>Facet的实现其实也非常简单，服务端（Adapter）在挂载服 务（Servant）的时候就制订了相应版本号。这时候客户端要调用此方法就必须提供正确的版本号（而非默认版本号）。</p>
<h2 id="持久化-（Feeze）"><a href="#持久化-（Feeze）" class="headerlink" title="持久化 （Feeze）"></a>持久化 （Feeze）</h2><p>一款对Servant服务进行管理和持久化的工具，Adapter可以注册多个Servant在内存中，当 Adapter接收到一个新的请求（request）后便去管理列表里面查找是否存在已有的Servant，如果存在则返回该Servant，如果不存在 则实例化一个新的Servant实例。当不停的实现新Servant之后势必会造成内存的激增已经CPU资源的浪费，而且一些很少被调用的Servant 也一直驻存在服务中。为此我们设定服务的Servant的上限，到达该上限后自动将“最少调用”的Servant状态保存在数据库（或文件等持久化设备） 中，然后关闭这些Servant，一旦有新的请求此Servant时再次获取原状态来激活Servant……</p>
<h2 id="服务装箱管理-（ICEBox）"><a href="#服务装箱管理-（ICEBox）" class="headerlink" title="服务装箱管理 （ICEBox）"></a>服务装箱管理 （ICEBox）</h2><p>从名字就可以看出来，它是一款装箱托管方案，类似于IIS，可以托管多个应用服务，并且每个服务是支持插拔式管理的， 相互之间不受影响，对ICE的应用做了接口设计，每个服务只是实现了 Ice.Services接口就可以了，这样一样让我们可以更专注的关于于我们的业务而非运行的平台。它为我们提供了统一的托管平台，是一个很不错的工 具。</p>
<h2 id="文件分发（ICEPatch2）"><a href="#文件分发（ICEPatch2）" class="headerlink" title="文件分发（ICEPatch2）"></a>文件分发（ICEPatch2）</h2><p>ICE最重要的功能就是多节点部署，以达到负载平衡或者容灾的目的，大多数时候 每个节点（一般而言是一台服务器）配置的应用程序都是一样的，当每次有更新或者新增应用的时候，便需要手工同步每个节点的文件，这样的手工操作显得十分繁 琐而且完全依赖操作人的行为。而ICEPatch2解决了这一难题，只要有一台以为的ICEPatch2服务在运行当中，就可以通过分发的方式同步其他各 个节点的文件，也就是说运维人员只需要维护一台机器的应用程序文件就可以了。</p>
<h2 id="发布-订阅-服务（ICEStorm"><a href="#发布-订阅-服务（ICEStorm" class="headerlink" title="发布/订阅 服务（ICEStorm)"></a>发布/订阅 服务（ICEStorm)</h2><h2 id="网络拓扑负载解决方案（ICEGrid）终极武器"><a href="#网络拓扑负载解决方案（ICEGrid）终极武器" class="headerlink" title="网络拓扑负载解决方案（ICEGrid）终极武器"></a>网络拓扑负载解决方案（ICEGrid）终极武器</h2><p>icegrid实际上是一系列组件的组合，形成了 一套强大的 文件分发、负载均衡、快捷部署等解决方案。这也是ICE功能中最为强大的一套，至于细节，有待后文慢慢道来。</p>
<p><strong>学习ICE</strong>，我们要从ICE的“语言”学起，<strong>简称SLICE</strong>（Simple Language Of ICE）。SLICE有自己独立的语法体系和结构，我们必须必须熟悉和遵守这些语法体系才能到达我们想要的效果。</p>
<p><strong>这些就是关于ICE的简单介绍 下一篇我会将iCE 中间语言的语法已经自己写一个简单的demo</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于ICE的介绍，网上的资料有很多，但是从应用的角度上去使用的并不多，在技术革新的今天我们可能更多的是去关注应用领域而非研究领域，因此根据 我个人的使用经验，想对ICE技术做一些总结和介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是ICE&quot;&gt;&lt;a href=&quot;#什么是ICE&quot; cla
    
    </summary>
    
      <category term="ZEROC_ICE" scheme="http://91fz.org/categories/ZEROC-ICE/"/>
    
    
      <category term="ICE" scheme="http://91fz.org/tags/ICE/"/>
    
      <category term="微服务，服务治理" scheme="http://91fz.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于RPC的总结</title>
    <link href="http://91fz.org/2015/08/20/rpc/"/>
    <id>http://91fz.org/2015/08/20/rpc/</id>
    <published>2015-08-19T16:00:00.000Z</published>
    <updated>2017-07-01T16:13:18.673Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家的都对RPC框架很熟悉，但有人经常混淆  所以写一篇文章简单介绍下，写的不好 欢迎底下评论留言</p>
<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<strong>RPC</strong>协议假定某些传输协议的存在，如<strong>TCP</strong>或<strong>UDP</strong>，为通信程序之间携带信息数据。<br>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p>
<p>通俗点就是它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。</p>
<h2 id="RPC起源"><a href="#RPC起源" class="headerlink" title="RPC起源"></a>RPC起源</h2><p>RPC 这个概念术语在上世纪 80 年代由 <strong>Bruce</strong> <strong>Jay</strong> <strong>Nelson</strong> 提出。这里我们追溯下当初开发 <strong>RPC</strong> 的原动机是什么？在 <strong>Nelson</strong> 的论文 “<strong>Implementing Remote Procedure Calls</strong>“ 中他提到了几点：</p>
<ul>
<li>简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。</li>
<li>高效：过程调用看起来十分简单而且高效。</li>
<li>通用：在单机计算中过程往往是不同算法部分间最重要的通信机制<h3 id="RPC-结构"><a href="#RPC-结构" class="headerlink" title="RPC 结构"></a>RPC 结构</h3><strong>Nelson</strong> 的论文中指出实现 RPC 的程序包括 5 个部分：</li>
<li><strong>User</strong></li>
<li><strong>User-stub</strong></li>
<li><strong>RPCRuntime</strong></li>
<li><strong>Server-stub</strong></li>
<li><strong>Server</strong>   </li>
</ul>
<p>这 5 个部分的关系如下图所示<br><img src="/images/rpc/01.png" alt="image">  </p>
<p><strong>RPC</strong> 服务方通过 <strong>RpcServer</strong> 去导出（<strong>export</strong>）远程接口方法，而客户方通过 <strong>RpcClient</strong> 去引入（<strong>import</strong>）远程接口方法。 客户方像调用本地方法一样去调用远程接口方法，<strong>RPC</strong> 框架提供接口的代理实现，实际的调用将委托给代理 <strong>RpcProxy</strong> 。 代理封装调用信息并将调用转交给 <strong>RpcInvoker</strong> 去实际执行。 在客户端的 <strong>RpcInvoker</strong> 通过连接器 <strong>RpcConnector</strong> 去维持与服务端的通道 RpcChannel， 并使用 <strong>RpcProtocol</strong> 执行协议编码（<strong>encode</strong>）并将编码后的请求消息通过通道发送给服务方。</p>
<p>RPC 服务端接收器 <strong>RpcAcceptor</strong> 接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（<strong>decode</strong>）。 解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果</p>
<p>这里 <strong>user</strong> 就是 <strong>client</strong> 端，当 <strong>user</strong> 想发起一个远程调用时，它实际是通过本地调用 <strong>user-stub</strong>。<strong>user-stub</strong> 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 <strong>RPCRuntime</strong> 实例传输到远端的实例。远端 <strong>RPCRuntime</strong> 实例收到请求后交给 <strong>server-stub</strong> 进行解码后发起本地端调用，调用结果再返回给 <strong>user</strong> 端。</p>
<h2 id="RPC-组件职责"><a href="#RPC-组件职责" class="headerlink" title="RPC 组件职责"></a>RPC 组件职责</h2><p>上面我们进一步拆解了 RPC 实现结构的各个组件组成部分，下面我们详细说明下每个组件的职责划分。</p>
<ul>
<li><strong>RpcServer</strong><br>负责导出（<strong>export</strong>）远程接口</li>
<li>RpcClient<br>负责导入（<strong>import</strong>）远程接口的代理实现</li>
<li>RpcProxy<br>远程接口的代理实现</li>
<li><strong>RpcInvoker</strong><br>客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回<br>服务方实现：负责调用服务端接口的具体实现并返回调用结果</li>
<li><strong>RpcProtocol</strong><br>负责协议编/解码</li>
<li><strong>RpcConnector</strong><br>负责维持客户方和服务方的连接通道和发送数据到服务方</li>
<li><strong>RpcAcceptor</strong><br>负责接收客户方请求并返回请求结果</li>
<li><strong>RpcProcessor</strong><br>负责在服务方控制调用过程，包括管理调用线程池、超时时间等</li>
<li><strong>RpcChannel</strong><br>数据传输通道</li>
</ul>
<h2 id="RPC-实现分析"><a href="#RPC-实现分析" class="headerlink" title="RPC 实现分析"></a>RPC 实现分析</h2><p>在进一步拆解了组件并划分了职责之后，这里以在 <strong>java</strong> 平台实现该 <strong>RPC</strong> 框架概念模型为例，详细分析下实现中需要考虑的因素。<br>导出远程接口<br>导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。 在 <strong>java</strong> 中导出接口的代码片段可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">DemoService demo   =new...;</div><div class="line">RpcServer   server =new...;</div><div class="line">server.export(DemoService.class, demo, options);</div></pre></td></tr></table></figure>
<p>我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 只导出 DemoService 中签名为 hi(String s) 的方法</div><div class="line">server.export(DemoService.class, demo,&quot;hi&quot;,newClass&lt;?&gt;[] &#123; String.class&#125;, options);</div></pre></td></tr></table></figure>
<p><strong>Java</strong> 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？ 这个本地调用的语义是通过 <strong>jvm</strong> 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。 如果前面 <strong>DemoService</strong> 接口有2个实现，那么在导出接口时就需要特殊标记不同的实现，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DemoService demo   =new...;</div><div class="line">DemoService demo2  =new...;</div><div class="line">RpcServer   server =new...;</div><div class="line">server.export(DemoService.class, demo, options);</div><div class="line">server.export(&quot;demo2&quot;, DemoService.class, demo2, options);</div></pre></td></tr></table></figure>
<h3 id="导入远程接口与客户端代理"><a href="#导入远程接口与客户端代理" class="headerlink" title="导入远程接口与客户端代理"></a><strong>导入远程接口与客户端代理</strong></h3><p>导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。 目前，大部分跨语言平台 <strong>RPC</strong> 框架采用根据 <strong>IDL</strong> 定义通过 <strong>code generator</strong> 去生成 <strong>stub</strong> 代码， 这种方式下实际导入的过程就是通过代码生成器在编译期完成的。 我所使用过的一些跨语言平台 <strong>RPC</strong> 框架如 <strong>CORBAR</strong>、<strong>WebService</strong>、<strong>ZEROC-ICE</strong>、<strong>Thrift</strong> 均是此类方式。</p>
<p>代码生成的方式对跨语言平台 <strong>RPC</strong> 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。 在 <strong>java</strong> 中导入接口的代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">RpcClient client =new...;</div><div class="line">DemoService demo = client.refer(DemoService.class);</div><div class="line">demo.hi(&quot;how are you?&quot;);</div></pre></td></tr></table></figure>
<p>在 java 中 <strong>import</strong> 是关键字，所以代码片段中我们用 <strong>refer</strong> 来表达导入接口的意思。 这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。 <strong>java</strong> 里至少提供了两种技术来提供动态代码生成，一种是 <strong>jdk</strong> 动态代理，另外一种是字节码生成。 动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。 两者权衡起来，牺牲一些性能来获得代码可读性和可维护性显得更重要。<br>协议编解码<br>客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。 出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。 我们先看下需要编码些什么信息：</p>
<h3 id="调用编码"><a href="#调用编码" class="headerlink" title="调用编码"></a>调用编码</h3><ul>
<li>接口方法 包括接口名、方法名   </li>
<li>方法参数 包括参数类型、参数值</li>
<li>调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等<h3 id="返回编码"><a href="#返回编码" class="headerlink" title="返回编码"></a>返回编码</h3></li>
<li>返回结果<br>接口方法中定义的返回值</li>
<li>返回码 异常返回码</li>
<li>返回异常信息 调用异常信息<br>除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。 这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。 如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。 下面给出一种概念上的 <strong>RPC</strong> 协议消息设计格式：<br><img src="/images/rpc/02.png" alt="image"></li>
</ul>
<ul>
<li><strong>magic</strong> : 协议魔数，为解码设计</li>
<li><strong>header size</strong>: 协议头长度，为扩展设计</li>
<li><strong>version</strong> : 协议版本，为兼容设计</li>
<li><strong>st</strong> : 消息体序列化类型</li>
<li><strong>hb</strong> : 心跳消息标记，为长连接传输层心跳设计</li>
<li><strong>ow</strong> : 单向消息标记，</li>
<li><strong>rp</strong> : 响应消息标记，不置位默认是请求消息</li>
<li><strong>status</strong> <strong>code</strong>: 响应消息状态码</li>
<li><strong>reserved</strong> : 为字节对齐保留</li>
<li><strong>message</strong> <strong>id</strong> : 消息 id</li>
<li><strong>body</strong> <strong>size</strong> : 消息体长度   </li>
</ul>
<h4 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a><strong>消息体</strong></h4><p>采用序列化编码，常见有以下格式</p>
<ul>
<li><strong>xml</strong> : 如 <strong>webservie</strong> <strong>SOAP</strong></li>
<li><strong>json</strong> : 如 <strong>JSON-RPC</strong></li>
<li><p><strong>binary</strong>: 如 <strong>thrift</strong>; <strong>hession</strong>; <strong>kryo</strong> 等<br>格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。 序列化我们关心三个方面：</p>
<p><strong>序列化和反序列化的效率，越快越好。</strong>   </p>
</li>
</ul>
<p><strong>序列化后的字节长度，越小越好</strong>  </p>
<p><strong>序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。</strong><br>上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。</p>
<h4 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h4><p>协议编码之后，自然就是需要将编码后的 <strong>RPC</strong> 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。 <strong>RPC</strong> 的应用场景实质是一种可靠的请求应答消息流，和 <strong>HTTP</strong> 类似。 因此选择长连接方式的 <strong>TCP</strong> 协议会更高效，与 <strong>HTTP</strong> 不同的是在协议层面我们定义了每个消息的唯一 <strong>id</strong>，因此可以更容易的复用连接。</p>
<p>既然使用长连接，那么第一个问题是到底 <strong>client</strong> 和 <strong>server</strong> 之间需要多少根连接？ 实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。 单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区， 因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。 所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升， 反而会增加连接管理的开销。</p>
<p>连接是由 client 端发起建立并维持。 如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。 如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。 为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。 心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位， 就是用来标记心跳消息的，它对业务应用透明。</p>
<h4 id="执行调用"><a href="#执行调用" class="headerlink" title="执行调用"></a>执行调用</h4><p>client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。 server stub 从前文的结构拆解中我们细分了 <strong>RpcProcessor</strong> 和 <strong>RpcInvoker</strong> 两个组件， 一个负责控制调用过程，一个负责真正调用。 这里我们还是以 <strong>java</strong> 中实现这两个组件为例来分析下它们到底需要做什么？</p>
<p>java 中实现代码的动态接口调用目前一般通过反射调用。 除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用， 因此 <strong>RpcInvoker</strong> 就是封装了反射调用的实现细节。</p>
<p>调用过程的控制需要考虑哪些因素，<strong>RpcProcessor</strong> 需要提供什么样地调用控制服务呢？ 下面提出几点以启发思考：</p>
<h4 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h4><p>每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。</p>
<h4 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h4><p>当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。</p>
<h4 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h4><p>当某个接口执行缓慢，而 <strong>client</strong> 端已经超时放弃等待后，<strong>server</strong> 端的线程继续执行此时显得毫无意义。<br>RPC 异常处理<br>无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。 在说异常处理之前，我们先比较下本地调用和 <strong>RPC</strong> 调用的一些差异：</p>
<p>本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。<br>本地调用只会抛出接口声明的异常，而远程调用还会跑出 <strong>RPC</strong> 框架运行时的其他异常。<br>本地调用和远程调用的性能可能差距很大，这取决于 <strong>RPC</strong> 固有消耗所占的比重。<br>正是这些区别决定了使用 <strong>RPC</strong> 时需要更多考量。 当调用远程接口抛出异常时，异常可能是一个业务异常， 也可能是 <strong>RPC</strong> 框架抛出的运行时异常（如：网络中断等）。 业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行， 而 <strong>RPC</strong> 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。</p>
<p>由于 <strong>RPC</strong> 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。 那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务， 只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。</p>
<h2 id="常见的-rpc-框架-double-grpc-motan-thrift-avro-性能对比"><a href="#常见的-rpc-框架-double-grpc-motan-thrift-avro-性能对比" class="headerlink" title="常见的 rpc 框架 double  grpc motan  thrift  avro  性能对比"></a><strong>常见的 rpc 框架 </strong>double<strong>  </strong>grpc motan  thrift  avro<strong>  性能对比</strong></h2><p><img src="/images/rpc/03.png" alt="image"><br><img src="/images/rpc/04.png" alt="image"><br><strong>下一篇讲一讲性能最好的  ZeroC——ICE</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家的都对RPC框架很熟悉，但有人经常混淆  所以写一篇文章简单介绍下，写的不好 欢迎底下评论留言&lt;/p&gt;
&lt;h2 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h
    
    </summary>
    
      <category term="RPC" scheme="http://91fz.org/categories/RPC/"/>
    
    
      <category term="RPC" scheme="http://91fz.org/tags/RPC/"/>
    
      <category term="RPC原理" scheme="http://91fz.org/tags/RPC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>QQ实用技术（从以前的博客拿过来的2011年手机写的 纯粹怀旧）</title>
    <link href="http://91fz.org/2015/08/11/QQ%E6%8A%80%E6%9C%AF/"/>
    <id>http://91fz.org/2015/08/11/QQ技术/</id>
    <published>2015-08-10T16:00:00.000Z</published>
    <updated>2017-07-01T16:16:51.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！"><a href="#首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！" class="headerlink" title="首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！"></a>首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！</h2><h3 id="盗取QQ的方式有"><a href="#盗取QQ的方式有" class="headerlink" title="盗取QQ的方式有"></a><strong>盗取QQ的方式有</strong></h3><ul>
<li>(1)<strong>远程木马盗号</strong>   </li>
<li><strong>(2)强制破解</strong></li>
<li><strong>(3)键盘纪录</strong>   </li>
<li><p><strong>(4)钓鱼网站，</strong><br>-<strong>(5)恶意申诉</strong></p>
<h4 id="第一种方法《远程木马盗号》"><a href="#第一种方法《远程木马盗号》" class="headerlink" title="第一种方法《远程木马盗号》"></a>第一种方法《远程木马盗号》</h4><p>远程木马盗号的软件有“<strong>盗Q黑侠</strong>，<strong>广外幽灵</strong>，<strong>QQ机器人</strong>，<strong>QQ远程攻击器</strong>，<strong>QQ流感</strong>，<strong>阿拉QQ大盗</strong>，<strong>QQ explorer</strong> <strong>QQ密码使者</strong>等， 它们的使用都差不多。<br>我用的是QQ邮箱收信，去邮箱设置里把软件地址设为白名单，例如:gzf@qinan.me，然后填写收件地址(这个区别前面的是要盗的号的邮箱)。还有发件地址(就是你收密码和发邮件的邮箱).   </p>
</li>
<li><p><strong>第二步</strong>，生成木马(这个是软件自带)   </p>
</li>
<li><p><strong>第三步</strong>  相当重要，重命名该木马，取一个吸引人的名字，例如:美女裸照，然后修改后缀(这个可以百度搜软件)，木马一般都是可运行程序，<strong>后缀是exe</strong>，要骗警惕的人不容易，那我们可以把他换成图片后缀(<strong>jpg</strong>，<strong>gif</strong>，等)音乐后缀(mp3，wma等)视频后缀(mp4，Avi，flv，mrvb，等)     </p>
</li>
<li><strong>第四步</strong>，发邮件，一般把木马藏在附件里面，然后等那人运行木马后，<strong>我们可以在邮箱里查看密码和IP</strong>，</li>
</ul>
<h4 id="第二种方法是《本地破解》"><a href="#第二种方法是《本地破解》" class="headerlink" title="第二种方法是《本地破解》"></a><strong>第二种方法是《本地破解》</strong></h4><p>这种成功率低的伤不起，之所以我用过，因为比较简单，就是用QQ暴力破解，下载词典，然后输入QQ号码，先猜可能的密码，例如:我确定某人的密码是纯数字，就选数字词典，然后就等待破解，<br>如果有字母就在词典里加字母就可以了。</p>
<h4 id="第三种《键盘纪录》"><a href="#第三种《键盘纪录》" class="headerlink" title="第三种《键盘纪录》"></a>第三种《键盘纪录》</h4><p>这种在网吧比较好用，下载键盘纪录软件(一定要能躲过还原精灵的那种，如果家庭电脑就没必要)注意点有二，第一要安装正确，二记住键盘输入纪录所在文件夹，这个是最简单的，可以直接查看。但是，如果用软件盘输入它就无能为力了！嘿嘿！   </p>
<h4 id="第四种就是《恶意申诉》"><a href="#第四种就是《恶意申诉》" class="headerlink" title="第四种就是《恶意申诉》"></a>第四种就是《恶意申诉》</h4><p>这个成功油水肥，可以改密保问题，是我常用的一种，申诉大家都会，不多说，注意点有，你必须有2个以上的小号，加的目标号码时间越长成功率越高，三不知道的不要乱猜，据我的经验，一般申请的都是网页免费申请，不多说，具体操作，自己把握，<br>第五钓鱼网站，这个从去年开始比较流行，现在中毒转发减肥和色 情聊天的都是这么中毒的，这个需要熟悉网站制作，要求比较高，比较麻烦，就不多说！</p>
<h5 id="下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单"><a href="#下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单" class="headerlink" title="下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单"></a>下面我根据自己多年的经验给大家提点意见其实，防范木马盗号很简单</h5><h5 id="1，拒绝好奇心"><a href="#1，拒绝好奇心" class="headerlink" title="1，拒绝好奇心"></a>1，拒绝好奇心</h5><p>不要接收陌生人的离线文件，熟人不知道什么东西的情况下就也不乱接，包括邮件里面的附件。（尤其多人转发的那种邮件）</p>
<h5 id="2，IP代理"><a href="#2，IP代理" class="headerlink" title="2，IP代理"></a>2，IP代理</h5><p>再QQ登录框下面的高级设置里(找不到你的iP地址木马无法攻击)<br>键盘纪录防范，只要软键盘输入就行了，</p>
<h5 id="3，暴力破解防范"><a href="#3，暴力破解防范" class="headerlink" title="3，暴力破解防范"></a>3，暴力破解防范</h5><p>密码越复杂越好，你数字中加一个标点符号，破解难度就得翻几倍。</p>
<h5 id="4，恶意申诉"><a href="#4，恶意申诉" class="headerlink" title="4，恶意申诉"></a>4，恶意申诉</h5><p>只有一个办法，绑钉自己身份证(前提是别人不知道你的身份证号码和姓名)</p>
<h5 id="5，鱼肉，"><a href="#5，鱼肉，" class="headerlink" title="5，鱼肉，"></a>5，鱼肉，</h5><p>记住一句话就可以，天上不掉馅饼，掉陷井，不要去玩色 站，和黑基，开挂等。</p>
<h5 id="6看好友隐身和ip地址的软件"><a href="#6看好友隐身和ip地址的软件" class="headerlink" title="6看好友隐身和ip地址的软件"></a>6看好友隐身和ip地址的软件</h5><p>qq彩虹       赛博qq</p>
<h5 id="从初三玩-qq有6，7年了-以上就是我对各位童鞋的各种悲剧的一些建议！"><a href="#从初三玩-qq有6，7年了-以上就是我对各位童鞋的各种悲剧的一些建议！" class="headerlink" title="从初三玩 qq有6，7年了  以上就是我对各位童鞋的各种悲剧的一些建议！"></a>从初三玩 qq有6，7年了  以上就是我对各位童鞋的各种悲剧的一些建议！</h5><h3 id="（以前用手机写的-还记得是Mtk的，纯粹为了怀旧，以上软件用不了）"><a href="#（以前用手机写的-还记得是Mtk的，纯粹为了怀旧，以上软件用不了）" class="headerlink" title="（以前用手机写的 还记得是Mtk的，纯粹为了怀旧，以上软件用不了）"></a>（以前用手机写的 还记得是Mtk的，纯粹为了怀旧，以上软件用不了）</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！&quot;&gt;&lt;a href=&quot;#首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范措施！！&quot; class=&quot;headerlink&quot; title=&quot;首先，我给大家介绍几种下盗号有哪几种方法，然后在讲解防范
    
    </summary>
    
      <category term="以前" scheme="http://91fz.org/categories/%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="盗取QQ" scheme="http://91fz.org/tags/%E7%9B%97%E5%8F%96QQ/"/>
    
      <category term="QQ技术" scheme="http://91fz.org/tags/QQ%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>安装ZeroC-ICE</title>
    <link href="http://91fz.org/2015/08/10/%E5%AE%89%E8%A3%85Zero-ICE/"/>
    <id>http://91fz.org/2015/08/10/安装Zero-ICE/</id>
    <published>2015-08-09T16:00:00.000Z</published>
    <updated>2017-06-26T09:52:15.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-安装"><a href="#ubuntu-安装" class="headerlink" title="ubuntu 安装"></a>ubuntu 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">wget https://zeroc.com/download/GPG-KEY-zeroc-release sudo apt-key add GPG-KEY-zeroc-release sudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot; sudo apt-get update sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-dev</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">wget https://zeroc.com/download/GPG-KEY-zeroc-release</div><div class="line">sudo apt-key add GPG-KEY-zeroc-release</div><div class="line">sudo apt-add-repository &quot;deb http://zeroc.com/download/apt/ubuntu15.10 stable main&quot;</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-dev</div><div class="line">Ubuntu 15.04</div><div class="line"></div><div class="line">wget https://zeroc.com/download/GPG-KEY-zeroc-release</div><div class="line">sudo apt-key add GPG-KEY-zeroc-release</div><div class="line">sudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu15.04 stable main&quot;</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-dev</div><div class="line">Ubuntu 14.04</div><div class="line"></div><div class="line">wget https://zeroc.com/download/GPG-KEY-zeroc-release</div><div class="line">sudo apt-key add GPG-KEY-zeroc-release</div><div class="line">sudo apt-add-repository &quot;deb https://zeroc.com/download/apt/ubuntu14.04 stable main&quot;</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install zeroc-ice-all-runtime zeroc-ice-all-dev</div><div class="line">GPG Key</div><div class="line"></div><div class="line">The Linux binary distributions are signed with our release key.</div><div class="line">Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997</div><div class="line">Sample Programs</div><div class="line"></div><div class="line">A collection of sample programs are available on GitHub. You can download them by running the following command:</div><div class="line">git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.git</div><div class="line">Refer to GitHub&apos;s help page for more information.</div></pre></td></tr></table></figure>
<h2 id="centos-安装"><a href="#centos-安装" class="headerlink" title="centos 安装"></a>centos 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   Install on Red Hat Enterprise Linux</div><div class="line"></div><div class="line">Documentation: Using the Linux Binary Distributions</div><div class="line">Includes: Runtime and SDK for Ice for C++, Java, PHP, and all Ice services.</div><div class="line">Red Hat Enterprise Linux 7</div><div class="line"></div><div class="line">Prerequisite: You may need to enable the RHEL 7 Server Optional repository for several dependencies.</div><div class="line">cd /etc/yum.repos.d</div><div class="line">sudo wget https://zeroc.com/download/rpm/zeroc-ice-el7.repo</div><div class="line">sudo yum install ice-all-runtime ice-all-devel</div><div class="line">Red Hat Enterprise Linux 6</div><div class="line"></div><div class="line">cd /etc/yum.repos.d</div><div class="line">sudo wget https://zeroc.com/download/rpm/zeroc-ice-el6.repo</div><div class="line">sudo yum install ice-all-runtime ice-all-devel</div><div class="line">GPG Key</div><div class="line"></div><div class="line">The Linux binary distributions are signed with our release key.</div><div class="line">Fingerprint: DC66 ECCB 94F2 797F D4D4 ADA7 5E6D A833 0613 2997</div><div class="line">Sample Programs</div><div class="line"></div><div class="line">A collection of sample programs are available on GitHub. You can download them by running the following command:</div><div class="line">git clone -b 3.6 https://github.com/zeroc-ice/ice-demos.git</div><div class="line">Refer to GitHub&apos;s help page for more information.</div></pre></td></tr></table></figure>
<p>** 下一篇介绍用法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ubuntu-安装&quot;&gt;&lt;a href=&quot;#ubuntu-安装&quot; class=&quot;headerlink&quot; title=&quot;ubuntu 安装&quot;&gt;&lt;/a&gt;ubuntu 安装&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>centos redis 源码安装配置</title>
    <link href="http://91fz.org/2014/12/18/centosredis/"/>
    <id>http://91fz.org/2014/12/18/centosredis/</id>
    <published>2014-12-17T16:00:00.000Z</published>
    <updated>2017-07-04T10:18:18.982Z</updated>
    
    <content type="html"><![CDATA[<p>centos redis 源码安装配置</p>
<p>载redis源码，并进行相关操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-3.2.3.tar.gz</div><div class="line"></div><div class="line">tar -zxvf redis-3.2.3.tar.gz</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv redis-3.2.3 redis</div></pre></td></tr></table></figure>
<p><img src="/images/redis/0.png" alt="image"> </p>
<p>解压完毕后，现在开始安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd redis</div><div class="line"></div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p><img src="/images/redis/1.png" alt="image"></p>
<p>如果出现上图 则是没有安装编译环境 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc</div></pre></td></tr></table></figure>
<p><img src="/images/redis/2.png" alt="image"></p>
<p>出现上图 就安装好编译环境了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>
<p>继续执行  发现又出错误了   </p>
<p><img src="/images/redis/3.png" alt="image">   </p>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make MALLOC=libc</div><div class="line">make install</div></pre></td></tr></table></figure>
<p><img src="/images/redis/4.png" alt="image">   </p>
<p>到此安装成功！！！   </p>
<p>可查看，/usr/local/bin下已有这些文件。<br>注意：若此时执行redis-server –v (查看版本命令)，若提示redis-server command not found，则需要将/usr/local/bin目录加到环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/profil</div></pre></td></tr></table></figure>
<p>把PATH=/usr/local/bin:$PATH<br>export PATH<br>添加到里面<br>要是刚才的修改马上生效，需要执行以下代码   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
<p>时再查看系统环境变量，就能看见刚才加的东西已经生效了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost utils]# echo $PATH</div><div class="line">/usr/local/bin:/usr/java/jdk1.8.0_131/bin:/usr/java/jdk1.8.0_131/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/root/bin:/usr/local/bin</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>通过上图，我们可以很容易的看出，redis安装到/usr/local,/usr/local/bin,/usr/local/share,/usr/local/include,/usr/local/lib,/usr/local/share/man目录下。</p>
<p>然后再切换到utils目录下，执行redis初始化脚本install_server.sh，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd utils/</div><div class="line"></div><div class="line">./install_server.sh</div></pre></td></tr></table></figure>
<p><img src="/images/redis/5.png" alt="image"><br>通过上图，我们可以看出redis初始化后redis配置文件为/etc/redis/6379.conf，日志文件为/var/log/redis_6379.log，数据文件dump.rdb存放到/var/lib/redis/6379目录下，启动脚本为/etc/init.d/redis_6379。</p>
<h2 id="修改配置文件，配置参数"><a href="#修改配置文件，配置参数" class="headerlink" title="修改配置文件，配置参数"></a>修改配置文件，配置参数</h2><p>打开、etc/redis 编辑6379.conf（重命名为redis.conf）我没有其他需求 所以目录不修改</p>
<h2 id="持久化打开"><a href="#持久化打开" class="headerlink" title="持久化打开"></a>持久化打开</h2><p>默认rdb，可选择是否开启aof，若开启，修改配置文件appendonly</p>
<h2 id="开启后台运行"><a href="#开启后台运行" class="headerlink" title="开启后台运行"></a>开启后台运行</h2><p>修改daemonize属性改成 yes<br><img src="/images/redis/7.png" alt="image">   </p>
<p>配置成功！！！   </p>
<h2 id="redis添加成服务"><a href="#redis添加成服务" class="headerlink" title="redis添加成服务"></a>redis添加成服务</h2><p>创建redis启动脚本<br>拷贝解压包下utils下redis启动脚本至/etc/init.d/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp  /usr/local/gzf/redis/redis/utils/redis_init_script /etc/init.d/</div></pre></td></tr></table></figure>
<p>修改脚本配置（如果之前改过etc/redis下配置文件名字的话）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/rc.d/init.d/redis_init_script</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CONF=&quot;/etc/redis/redis.conf&quot;</div></pre></td></tr></table></figure>
<p>保存<br>退出<br>至此，在/etc/init.d/目录下，已经可以通过service redis start/stop 命令启动和关闭redis</p>
<p>若在其他目录下，不能够使用这2个命令，请继续配置   </p>
<p><strong>给启动脚本添加权限</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x /etc/init.d/redis</div></pre></td></tr></table></figure>
<h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig redis on</div></pre></td></tr></table></figure>
<p>如果运行报错，提示<br><img src="/images/redis/8.png" alt="image">    </p>
<p>是因为没有在启动脚本里加入redis启动优先级信息，可添加如下</p>
<p><img src="/images/redis/9.png" alt="image">    </p>
<p>然后 运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig redis on</div></pre></td></tr></table></figure>
<p><img src="/images/redis/10.png" alt="image"> </p>
<p>如果另一台机器链接不上 如下：<br><img src="/images/redis/11.png" alt="image"><br>（有可能是防火墙跟配置问题）<br>打开 /etc/redis/redis.conf  注释掉 bind 127.0.0.1   </p>
<p>在redis3.2之后，redis增加了protected-mode，在这个模式下，即使注释掉了bind 127.0.0.1，再访问redisd时候还是报错   </p>
<p>修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected-mode no</div></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi  /etc/sysconfig/iptables</div></pre></td></tr></table></figure>
<p>在 icmp-host-prohibited  上面加入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT</div></pre></td></tr></table></figure>
<p>然后 重启防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">services iptables  restart</div></pre></td></tr></table></figure></p>
<p><strong>完工！！！！写的不好，欢迎大家提意见。。。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;centos redis 源码安装配置&lt;/p&gt;
&lt;p&gt;载redis源码，并进行相关操作:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/
    
    </summary>
    
      <category term="Redis" scheme="http://91fz.org/categories/Redis/"/>
    
    
      <category term="centos" scheme="http://91fz.org/tags/centos/"/>
    
      <category term="Redis" scheme="http://91fz.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JAVA实现类似百度文库在线浏览</title>
    <link href="http://91fz.org/2014/06/28/javare/"/>
    <id>http://91fz.org/2014/06/28/javare/</id>
    <published>2014-06-27T16:00:00.000Z</published>
    <updated>2017-07-01T16:12:39.317Z</updated>
    
    <content type="html"><![CDATA[<p>前言：由于是个教育评比项目，需求要上传Excel，word，等 还要求在线浏览，本来刚参加工作一年，对我来说难度还是有的。查了好多资料发现网上的都千篇一律，真的头疼，而且时间也很短。但还是做出来了，写个博客，记录下<br>时间是 2014年6月28日23:24:23</p>
<h2 id="研究阶段"><a href="#研究阶段" class="headerlink" title="研究阶段"></a>研究阶段</h2><p> 发现网上大多都是一下几种实现方式 </p>
<ul>
<li><p>1.Txt/Word/Excel/PPT=&gt;PDF(OpenOffice+JodConverter)=&gt;SWF(pdf2swf)=&gt;FlexPaper浏览  </p>
</li>
<li><p>2.Txt/Word/Excel/PPT=&gt;PDF(MSOffice+JACOB)=&gt;SWF(pdf2swf)=&gt;FlexPaper浏览</p>
</li>
<li><p>3.Txt/Word/Excel/PPT=&gt;SWF (FlashPaper)=&gt; FlexPaper浏览</p>
</li>
<li></li>
<li>4.Txt/Word/Excel/PPT=&gt;SWF(print2flash)=&gt; FlexPaper浏览</li>
</ul>
<p>1,2两种实现方式相对比较复杂，需要先将其他类型转换为PDF类型，再转成SWF类型在容器中显示。所以先下后2种，先说说flashpaper吧，此款软件确实是转换格式的神器，可惜是收费的。不过可以试用30天，对于这种小型的可试用的软件，但不适合开发、再说说<strong>print2flash，</strong>这款软件是开源的，也能实现转换swf的功能，但是上网找了半天，关于它的代码资料很是匮乏。Java的更是凤毛麟角，无从下手，只好先晾着。鉴于经典案例及网上资料的丰富性，我最终还是用第一种的组合上了。</p>
<p>资料和工具准备：</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><strong>OpenOffice</strong>    <a href="http://zh.openoffice.org/new/zh_cn/downloads.html" target="_blank" rel="external">http://zh.openoffice.org/new/zh_cn/downloads.html</a></li>
<li><strong>JodConverter</strong>    <a href="http://dldx.csdn.net/fd.php?i=992314146801277&amp;s=08dbee956e2dda1a95aa8cbf4df197b" target="_blank" rel="external">http://dldx.csdn.net/fd.php?i=992314146801277&amp;s=08dbee956e2dda1a95aa8cbf4df197b</a></li>
<li><strong>Swftools(pdf2swf)</strong>  <a href="http://dldx.csdn.net/fd.php?i=389133735472350&amp;s=2f7430ad3c00cca78ada8b4671a50b24" target="_blank" rel="external">http://dldx.csdn.net/fd.php?i=389133735472350&amp;s=2f7430ad3c00cca78ada8b4671a50b24</a></li>
<li><strong>FlexPaper</strong>    <a href="http://flexpaper.googlecode.com/files/FlexPaper_1.4.5_flash.zip" target="_blank" rel="external">http://flexpaper.googlecode.com/files/FlexPaper_1.4.5_flash.zip</a>   </li>
</ul>
<p>资料方面，大致搜索了百度文库和开源中国上的一些资料，其实都一样。感觉都是互相转载，不过前辈们已经为我们做了很多了，再次谢过各位分享的前辈。</p>
<h2 id="项目源码："><a href="#项目源码：" class="headerlink" title="项目源码："></a>项目源码：</h2><h3 id="ConvertServlet的servlet处理类代码如下："><a href="#ConvertServlet的servlet处理类代码如下：" class="headerlink" title="ConvertServlet的servlet处理类代码如下："></a>ConvertServlet的servlet处理类代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">package org.timothy.test.servlet;</div><div class="line"></div><div class="line">import java.io.File;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import javax.servlet.ServletException;</div><div class="line">import javax.servlet.http.HttpServlet;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line">import javax.servlet.http.HttpSession;</div><div class="line"></div><div class="line">import com.artofsolving.jodconverter.DocumentConverter;</div><div class="line">import com.artofsolving.jodconverter.openoffice.connection.OpenOfficeConnection;</div><div class="line">import com.artofsolving.jodconverter.openoffice.connection.SocketOpenOfficeConnection;</div><div class="line">import com.artofsolving.jodconverter.openoffice.converter.OpenOfficeDocumentConverter;</div><div class="line"></div><div class="line">public class ConvertServlet extends HttpServlet &#123;</div><div class="line">	private File sourceFile;		//转换源文件</div><div class="line">	private File pdfFile;			//PDF目标文件</div><div class="line">	private File swfFile;			//SWF目标文件</div><div class="line">	private Runtime r;				</div><div class="line">	</div><div class="line">	public void init() throws ServletException &#123;</div><div class="line">		sourceFile = new File(&quot;G:\\tomcat6\\webapps\\readonline\\swfFile\\1.doc&quot;);</div><div class="line">		pdfFile = new File(&quot;G:\\tomcat6\\webapps\\readonline\\swfFile\\1.pdf&quot;);</div><div class="line">		swfFile = new File(&quot;G:\\tomcat6\\webapps\\readonline\\swfFile\\Paper.swf&quot;);</div><div class="line">		System.out.println(&quot;第一步：生成文件对象，准备转换&quot;);</div><div class="line">	&#125;</div><div class="line">	public void doGet(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line"></div><div class="line">		doPost(request, response);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * The doPost method of the servlet. &lt;br&gt;</div><div class="line">	 *</div><div class="line">	 * This method is called when a form has its tag value method equals to post.</div><div class="line">	 * </div><div class="line">	 * @param request the request send by the client to the server</div><div class="line">	 * @param response the response send by the server to the client</div><div class="line">	 * @throws ServletException if an error occurred</div><div class="line">	 * @throws IOException if an error occurred</div><div class="line">	 */</div><div class="line">	public void doPost(HttpServletRequest request, HttpServletResponse response)</div><div class="line">			throws ServletException, IOException &#123;</div><div class="line">		response.setContentType(&quot;text/html&quot;);</div><div class="line">		//转换成pdf文件</div><div class="line">		if(sourceFile.exists()) &#123;</div><div class="line">			if(!pdfFile.exists()) &#123;</div><div class="line">				OpenOfficeConnection connection = new SocketOpenOfficeConnection(8100);</div><div class="line">				try &#123;</div><div class="line">					connection.connect();</div><div class="line">					DocumentConverter converter = new OpenOfficeDocumentConverter(connection);   </div><div class="line">					converter.convert(sourceFile, pdfFile);</div><div class="line">					pdfFile.createNewFile();</div><div class="line">					connection.disconnect();  </div><div class="line">					System.out.println(&quot;第二步：转换为PDF格式	路径&quot; + pdfFile.getPath());</div><div class="line">				&#125; catch (java.net.ConnectException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">					System.out.println(&quot;OpenOffice服务未启动&quot;);</div><div class="line">					throw e;</div><div class="line">				&#125; catch (com.artofsolving.jodconverter.openoffice.connection.OpenOfficeException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">					System.out.println(&quot;读取文件失败&quot;);</div><div class="line">					throw e;</div><div class="line">				&#125; catch (Exception e)&#123;</div><div class="line">					e.printStackTrace();</div><div class="line">					try &#123;</div><div class="line">						throw e;</div><div class="line">					&#125; catch (Exception e1) &#123;</div><div class="line">						e1.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; else &#123;</div><div class="line">				System.out.println(&quot;已转换为PDF，无需再次转换&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125; else &#123;</div><div class="line">			System.out.println(&quot;要转换的文件不存在&quot;);</div><div class="line">		&#125; </div><div class="line">		//转换成swf文件</div><div class="line">		r = Runtime.getRuntime();</div><div class="line">		</div><div class="line">		new Thread()&#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void run() &#123;</div><div class="line">				if(!swfFile.exists())&#123;</div><div class="line">					</div><div class="line">					if(pdfFile.exists()) &#123;</div><div class="line">						try &#123;</div><div class="line">							System.out.println(&quot;E:/SWFTools/pdf2swf.exe &quot; + pdfFile.getPath() +</div><div class="line">									&quot; -o &quot; + swfFile.getPath() + &quot; -T 9&quot;);</div><div class="line">							</div><div class="line">							Process p = r.exec(&quot;E:/SWFTools/pdf2swf.exe &quot; + pdfFile.getPath() + &quot; -o &quot; + swfFile.getPath() + &quot; -T 9&quot;);</div><div class="line">							p.waitFor();</div><div class="line">							swfFile.createNewFile();</div><div class="line">							System.out.println(&quot;第三步：转换为SWF格式	路径：&quot; + swfFile.getPath());</div><div class="line">							System.out.println(&quot;第si步：转换为SWF格式mingcheng：&quot; + swfFile.getName());</div><div class="line">//							if(pdfFile.exists()) &#123;</div><div class="line">//								pdfFile.delete();</div><div class="line">//							&#125;</div><div class="line">						&#125; catch (Exception e) &#123;</div><div class="line">							e.printStackTrace();</div><div class="line">							try &#123;</div><div class="line">								throw e;</div><div class="line">							&#125; catch (Exception e1) &#123;</div><div class="line">								// TODO Auto-generated catch block</div><div class="line">								e1.printStackTrace();</div><div class="line">							&#125;</div><div class="line">						&#125;</div><div class="line">					&#125; else &#123;</div><div class="line">						System.out.println(&quot;PDF文件不存在，无法转换&quot;);</div><div class="line">					&#125;</div><div class="line">				&#125; else &#123;</div><div class="line">					System.out.println(&quot;已经转为SWF文件，无需再次转换&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		HttpSession session = request.getSession();</div><div class="line">		session.setAttribute(&quot;fileName&quot;, swfFile.getName());</div><div class="line">		System.out.println(&quot;我是测试:&quot;+session.getAttribute(&quot;fileName&quot;));</div><div class="line">		response.sendRedirect(request.getContextPath()+&quot;/readFile.jsp&quot;);</div><div class="line">	&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="读取文件页面Readfile-Jsp代码如下："><a href="#读取文件页面Readfile-Jsp代码如下：" class="headerlink" title="读取文件页面Readfile.Jsp代码如下："></a>读取文件页面Readfile.Jsp代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</div><div class="line">&lt;%</div><div class="line">String path = request.getContextPath();</div><div class="line">String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;</div><div class="line">%&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot; xml:lang=&quot;en&quot;&gt;	</div><div class="line">  &lt;head&gt;</div><div class="line">    </div><div class="line">    &lt;title&gt;在线阅读&lt;/title&gt;</div><div class="line">        &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; </div><div class="line">			html, body	&#123; height:100%; &#125;</div><div class="line">			body &#123; margin:0; padding:0; overflow:auto; &#125;   </div><div class="line">			#flashContent &#123; display:none; &#125;</div><div class="line">        &lt;/style&gt; </div><div class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;flexpaper/js/flexpaper_flash_debug.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script type=&quot;text/javascript&quot; src=&quot;flexpaper/js/jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script type=&quot;text/javascript&quot; src=&quot;flexpaper/js/flexpaper_flash.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  </div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div style=&quot;position:absolute;left:200px;top:10px;&quot;&gt;</div><div class="line">    </div><div class="line">	       &lt;center&gt; &lt;a id=&quot;viewerPlaceHolder&quot; style=&quot;width:1000px;height:800px;display:block&quot;&gt;努力加载中............&lt;/a&gt;&lt;/center&gt;</div><div class="line">	        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	        $(document).ready(function()&#123;</div><div class="line">	        var fp = new FlexPaperViewer(	</div><div class="line">						 &apos;flexpaper/FlexPaperViewer&apos;,</div><div class="line">						 &apos;viewerPlaceHolder&apos;, &#123; config : &#123;</div><div class="line">						 SwfFile : escape(&apos;http:\/\/192.168.0.13:8080\/readonline\/swfFile\/&lt;%=request.getAttribute(&quot;fileName&quot;)%&gt;&apos;),</div><div class="line">						 Scale : 0.6, </div><div class="line">						 ZoomTransition : &apos;easeOut&apos;,</div><div class="line">						 ZoomTime : 0.5,</div><div class="line">						 ZoomInterval : 0.2,</div><div class="line">						 FitPageOnLoad : true,</div><div class="line">						 FitWidthOnLoad : false,</div><div class="line">						 PrintEnabled : true,</div><div class="line">						 FullScreenAsMaxWindow : false,</div><div class="line">						 ProgressiveLoading : true,</div><div class="line">						 MinZoomSize : 0.2,</div><div class="line">						 MaxZoomSize : 5,</div><div class="line">						 SearchMatchAll : false,</div><div class="line">						 InitViewMode : &apos;Portrait&apos;,</div><div class="line">						 </div><div class="line">						 ViewModeToolsVisible : true,</div><div class="line">						 ZoomToolsVisible : true,</div><div class="line">						 NavToolsVisible : true,</div><div class="line">						 CursorToolsVisible : true,</div><div class="line">						 SearchToolsVisible : true,</div><div class="line">  						</div><div class="line">  						 localeChain: &apos;zh_CN&apos;</div><div class="line">						 &#125;&#125;);</div><div class="line">	        &#125;);</div><div class="line">	     		</div><div class="line">	        &lt;/script&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        </div><div class="line">   &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>用官方的Paper.swf作为测试，只需要将<strong>SwfFile</strong>的地址改掉。<br>显示效果如下：<br><img src="/images/javare/01.png" alt="image"> </p>
<p><strong>总结：终于熬夜研究的差不多了，就等明天去公司了，周末也加班，感叹一下，毕竟还是菜鸟努力加油。。。反正基本差不多了，就差放进项目优化了！就这样吧。那些参数有时间在整理咯、、</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：由于是个教育评比项目，需求要上传Excel，word，等 还要求在线浏览，本来刚参加工作一年，对我来说难度还是有的。查了好多资料发现网上的都千篇一律，真的头疼，而且时间也很短。但还是做出来了，写个博客，记录下&lt;br&gt;时间是 2014年6月28日23:24:23&lt;/p&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://91fz.org/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://91fz.org/tags/JAVA/"/>
    
      <category term="仿百度文库" scheme="http://91fz.org/tags/%E4%BB%BF%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Centos 安装JDK</title>
    <link href="http://91fz.org/2013/12/18/centosjdk/"/>
    <id>http://91fz.org/2013/12/18/centosjdk/</id>
    <published>2013-12-17T16:00:00.000Z</published>
    <updated>2017-07-04T04:10:13.975Z</updated>
    
    <content type="html"><![CDATA[<p>首先，在你的服务器上运行一下更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum update</div></pre></td></tr></table></figure>
<p>然后，在您的系统上搜索，任何版本的已安装的JDK组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -qa | grep -E &apos;^open[jre|jdk]|j[re|dk]&apos;</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gobject-introspection-1.36.0-4.el7.x86_64</div><div class="line">pygobject3-base-3.8.2-4.el7.x86_64</div></pre></td></tr></table></figure>
<p>输入以下命令，查看已安装的JAVA版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -version</div></pre></td></tr></table></figure>
<p>如果你之前已经安装了JAVA1.6或1.7的版本，请执行下列命令，将他们卸载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum remove java-1.6.0-openjdk</div><div class="line">yum remove java-1.7.0-openjdk</div></pre></td></tr></table></figure>
<p>在我写这个教程的时候最新版本的JDK是JDK 8u131。首先我们来下载最新版本的 Java版本</p>
<p>到Oracle Java download page下载和计算机架构相匹配的版本。</p>
<p>因为我用的是 64bit CentOS 6.5 server，说以我下载的是64位的rpm包。</p>
<p>然后，到你的下载目录，运行以下的命令来安装它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -ivh rpm -ivh jdk-7u25-linux-x64.rpm</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@localhost gzf]# rpm -ivh jdk-7u25-linux-x64.rpm </div><div class="line">Preparing...                ########################################### [100%]</div><div class="line">   1:jdk1.7.0_25          ########################################### [100%]</div><div class="line">Unpacking JAR files...</div><div class="line">	tools.jar...</div><div class="line">	plugin.jar...</div><div class="line">	javaws.jar...</div><div class="line">	deploy.jar...</div><div class="line">	rt.jar...</div><div class="line">	jsse.jar...</div><div class="line">	charsets.jar...</div><div class="line">	localedata.jar...</div></pre></td></tr></table></figure>
<p>现在，用一下的命令来查看你安装的JDK的版本号。</p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost gzf]# java -version</div><div class="line">java version &quot;1.7.0_25&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.7.0_25-b11)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.25-b11, mixed mode)</div></pre></td></tr></table></figure>
<p>正如上面所显示的那样，最新版本的JDK已经被安装好了<br>设置全局环境变量</p>
<p>我们可以用如下命令来轻松设置你安装JDK的环境变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/java/1.7.0_25/</div><div class="line">export PATH=$PATH:$JAVA_HOME</div></pre></td></tr></table></figure>
<p>现在，让我们用下面的命令来查看JDK的环境变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $JAVA_HOME</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/java/1.8.0_25/</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo $PATH</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/java/1.7.0_25/</div></pre></td></tr></table></figure>
<p>然而，接下来的安装方法我们并不推荐。因为，安装路径会在机器重启以后会消失。为了使它保存下来，你需要把安装路径添加到系统的配置文件里。</p>
<p>做它之前，我们要在 <strong>/etc/profile.d/</strong> 下创建一个叫做 <strong>java.sh</strong>的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/profile.d/java.sh</div></pre></td></tr></table></figure>
<p>把下面的命令添加到文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">JAVA_HOME=/usr/java/1.7.0_25</div><div class="line">PATH=$JAVA_HOME/bin:$PATH</div><div class="line">export PATH JAVA_HOME</div><div class="line">export CLASSPATH=.</div></pre></td></tr></table></figure>
<p>保存并关闭文件。为了使它有执行的权限运行以下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x /etc/profile.d/java.sh</div></pre></td></tr></table></figure>
<p>接下来，使刚才改变的环境变量永久有效运行以下下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /etc/profile.d/java.sh</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，在你的服务器上运行一下更新。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
      <category term="JAVA" scheme="http://91fz.org/categories/JAVA/"/>
    
    
      <category term="centos" scheme="http://91fz.org/tags/centos/"/>
    
      <category term="JDK" scheme="http://91fz.org/tags/JDK/"/>
    
      <category term="JAVA" scheme="http://91fz.org/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>自己刷机的一些感触和经验</title>
    <link href="http://91fz.org/2012/10/11/rom/"/>
    <id>http://91fz.org/2012/10/11/rom/</id>
    <published>2012-10-10T16:00:00.000Z</published>
    <updated>2017-07-01T16:13:27.829Z</updated>
    
    <content type="html"><![CDATA[<p>首先我要说一下，其实，刷机的最高境界就是不刷，连超级权限就是<strong>root</strong>都不要，这是我这段时间的一些感触。    </p>
<p>对于<strong>root</strong>这个问题有些人认为可以卸载系统软件，美化字体，等等好处，但是，木马也会在你不知情的情况下获得超级权限，而且可以饶过全软件，从而获取你手机里的所有信息，我想，很少有人希望他成为第二个陈冠希吧！</p>
<h2 id="关于解锁"><a href="#关于解锁" class="headerlink" title="关于解锁"></a>关于解锁</h2><p>关于解锁，我还是希望轻易不要去解，因为你一解锁，手机厂商会不保修的，而且要再次锁手机，只有强刷官方固件，虽然简单，但许多官方固件是锁不住的！<br>如果看了上面这些你还是选择刷机，那么看下面的内容，也许对你有帮助！</p>
<h2 id="关于ROOT"><a href="#关于ROOT" class="headerlink" title="关于ROOT"></a>关于ROOT</h2><p>首先，我说下<strong>root</strong>吧，各种手机<strong>root</strong>的方法不一样，普遍的2.3左右的系统的话（<strong>安卓一键root</strong>）和（刷机精灵）是可以解决的，但是4.0的要按自己的手机型号找软件，有点麻烦，<strong>root</strong>一般不会出现问题，失败了重新来遍就可以了。。      </p>
<ul>
<li>第二步，就是刷入recovery，各种版本的用法不一样，像刷机精灵自带的5.04英文版的确定是关机健，刷<strong>recovery</strong>首先要让手机进入<strong>recovery</strong>模式，各种手机的操作方式网上都有，我就不说了，这要注意一点就是要确保<strong>adb</strong>驱动，<strong>usb</strong>调试没任何问题，然后根据工具的提示走就可以，这一步是不会成转的，但这一步刷不好，后面刷rom的时候成转可能比较大</li>
<li>第三步，下载你喜欢的<strong>rom</strong>，选择的时候看下评论，漏洞多不多，系统流畅度怎么样，费电程度等都是考虑因素，把下载好的固件放入内存卡中   <h2 id="关于刷机"><a href="#关于刷机" class="headerlink" title="关于刷机"></a>关于刷机</h2><h3 id="卡刷法"><a href="#卡刷法" class="headerlink" title="卡刷法"></a>卡刷法</h3>也就是<strong>recovery</strong>刷法，步骤如下…     当然前提是你手机已经<strong>root</strong>过了！</li>
<li>关掉快速启动，- 开机进入模式（手机型号不同，方法不同，自己网上找自己手机进入模式的方法）</li>
<li>然后选择清空缓存和数据，如果不双清，肯定成转，</li>
<li>选择从<strong>sd卡</strong>选择<strong>zip安装</strong>，过程大概在几十秒，然后返回重启手机，第一次启动速度有点慢，属于正常情况。   <h3 id="线刷法"><a href="#线刷法" class="headerlink" title="线刷法"></a>线刷法</h3>前提是也是要<strong>roo</strong>t过！线刷的话，失败了后救砖是比较麻烦，而且对数据连接要求高，就是再刷机过程中如果数据线连接不好就容易失败，救砖的话不好救，所以线刷之前还是刷一次<strong>recovery</strong>，以防失败后救砖，</li>
<li>把下载好的固件包放在线刷工具可以导到的目录下，</li>
<li>然后启动工具，工具自己找，刷机大师，精灵都是可以的，然后连接手机，（<strong>确保usb..adb模式开启</strong>），</li>
<li>然后按步骤导入固件包，进行云检测，然后你可以休息了，它自己会解锁手机，把包刷进手机，自动进行刷机，这个时间有点长，刷完自动重启，<h3 id="关于救砖"><a href="#关于救砖" class="headerlink" title="关于救砖"></a>关于救砖</h3></li>
<li>（1）手机是否刷过<strong>recovery</strong>  </li>
<li>（2）手机是否可以进入<strong>fastboot</strong>模式  </li>
<li>（3）手机是否可以进行强刷官方固件   </li>
<li>如果说你手机刷过r<strong>ecovery</strong>，这就简单了，多下载几个<strong>rom</strong>包进行卡刷或者线刷，救砖我比较推荐用线刷，如果还不行就强刷官方固件，<br>如果手机可以进入<strong>fastboot</strong>模式，那也好办，<strong>重刷recovery</strong>，然后进行卡刷，不行在线刷，实在不行强刷官方固件。</li>
</ul>
<p><strong>总结：</strong>如果以上方法都不行，那只剩强刷官方固件这一条路了，以C8812为例，下载官方固件，把一个dload文件夹放到手机自带内存的根目录下，关机，然后按住音量加和音量减和开机键，记得，是同时按住’，他会自动升级，时间大概三四分钟，如果出现粉屏，那你一定是把文件考到内存卡里了，而没考在手机自带内存中，<br>就这些吧，手机打字不容易，希望大家多多支持**</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我要说一下，其实，刷机的最高境界就是不刷，连超级权限就是&lt;strong&gt;root&lt;/strong&gt;都不要，这是我这段时间的一些感触。    &lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;root&lt;/strong&gt;这个问题有些人认为可以卸载系统软件，美化字体，等等好处，但是，木马也
    
    </summary>
    
      <category term="以前" scheme="http://91fz.org/categories/%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="刷机" scheme="http://91fz.org/tags/%E5%88%B7%E6%9C%BA/"/>
    
      <category term="自己" scheme="http://91fz.org/tags/%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>ROM修改之厨房简介及环境配置</title>
    <link href="http://91fz.org/2012/10/10/Kitchen/"/>
    <id>http://91fz.org/2012/10/10/Kitchen/</id>
    <published>2012-10-09T16:00:00.000Z</published>
    <updated>2017-07-01T16:13:37.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-厨房简介及环境配置"><a href="#一-厨房简介及环境配置" class="headerlink" title="一.厨房简介及环境配置"></a>一.厨房简介及环境配置</h2><h3 id="1-厨房简介"><a href="#1-厨房简介" class="headerlink" title="1.厨房简介"></a>1.厨房简介</h3><p>厨房，是HTC android厨房的简称，是一款由国外ROM达人写的与DOS程序相似的ROM修改程序，目前各版本介绍及更新主要发布于国外著名玩机论坛XDA- Developers, 目前发布有linux版本和windows版本,在这里,花小祺只为大家介绍windows版本</p>
<h3 id="2-厨房支持的机型（ROM）"><a href="#2-厨房支持的机型（ROM）" class="headerlink" title="2.厨房支持的机型（ROM）"></a>2.厨房支持的机型（ROM）</h3><h4 id="1）HTC设备"><a href="#1）HTC设备" class="headerlink" title="1）HTC设备"></a>1）HTC设备</h4><ul>
<li>Buzz / Wildfire</li>
<li>Desire</li>
<li>Desire HD / Inspire 4G</li>
<li>Desire S</li>
<li>Desire Z</li>
<li>Dream / G1</li>
<li>Droid Eris</li>
<li>Evo 4G</li>
<li>Evo Shift 4G</li>
<li>HD2 </li>
<li>Hero / G2 Touch</li>
<li>Incredible</li>
<li>Incredible S</li>
<li>Legend</li>
<li>Magic / myTouch 3G</li>
<li>myTouch 3G Slide</li>
<li>myTouch 4G / Glacier</li>
<li>Nexus One</li>
<li>Tattoo / Click</li>
<li>Thunderbolt<br>理论支持一些其他机型的已Root的HTC手机（android操作系统）也有可能支持一些WindowsMobile等可以使用Android NAND ROM的机型</li>
</ul>
<h3 id="2）非HTC设备："><a href="#2）非HTC设备：" class="headerlink" title="2）非HTC设备："></a>2）非HTC设备：</h3><ul>
<li>戴尔 Streak 7</li>
<li>华为 U8100/U8110/U8120/U8150</li>
<li>LG Ally</li>
<li>LG GT540 Optimus</li>
<li>LG P500 </li>
<li>LG Shine Plus</li>
<li>LG Vortex</li>
<li>摩托罗拉 CLIQ / CLIQ XT</li>
<li>三星 Galaxy S - You must use RMGeren’s SGS version of this kitchen</li>
<li>三星 Nexus S<br>•索爱 Xperia X10 / X10 Mini / X10 Mini Pro - 不含 boot.img </li>
<li>T-Mobile Pulse</li>
</ul>
<h3 id="3）理论支持设备（还没正式确定）"><a href="#3）理论支持设备（还没正式确定）" class="headerlink" title="3）理论支持设备（还没正式确定）"></a>3）理论支持设备（还没正式确定）</h3><ul>
<li>摩托罗拉Droid</li>
<li>摩托罗拉Milestone（修改前需移除boot.img文件）</li>
</ul>
<p>由于我的电脑室win7系统 所以就以win7为例<br><strong>安装方法：</strong><br>首先学java语言的同学肯定自己电脑上已经配置好java环境了可以直接省略安装JDK这一步：</p>
<ul>
<li>下载后直接全默认安装JDK </li>
<li>最好默认C盘，如果在别的盘，下面的路径自行对应修改</li>
<li>设置环境变量：JAVA_HOME、PATH、CLASSPATH<br><strong>JAVA_HOME</strong>：<br><strong>我的电脑</strong>-&gt;<strong>属性</strong>-&gt;<strong>高级</strong>-&gt;单击“<strong>环境变量</strong>”按钮-&gt;单击“<strong>系统变量</strong>”区域的“<strong>新建</strong>”按钮-&gt;在“<strong>变量名</strong>”文本框中输入<strong>JAVA_HOME</strong>，在“<strong>变量值</strong>”文本框中输入<strong>JDK</strong>的安装路径（列如<strong>C:\Program Files\Java\jdk1.6.0_22</strong>）,单击<strong>确定</strong>   </li>
</ul>
<p><strong>PATH</strong>：在系统变量中查看<strong>PATH</strong>变量，如果存在<strong>PATH</strong>，则在最末尾多添加一个<strong>%JAVA_HOME%\bin</strong>;（<strong>直接添加，无需加空格之类的</strong>）。如果不存在，<strong>则新建变量PATH</strong>，设定变量值为：<strong>%JAVA_HOME%\bin</strong>;<br><strong>CLASSPATH</strong>：在系统变量中查看<strong>CLASSPATH</strong>变量，如果存在<strong>CLASSPATH</strong>，则在最末尾添加%JAVA_HOME%lib\dt.jar;%JAVA_HOME%\lib\tools.jar。如果不存在，则新建一个，设定变量值为：<strong>%JAVA_HOME%lib\dt.jar;%JAVA_HOME%\lib\tools.jar</strong>;<br><strong>完成以上步骤后，开始验证是否安装成功。</strong><br><strong>运行CMD（开始，运行，输入cmd，回车），输入：javac。假如出现了一堆如何使用java的帮助，那就是已经安装成功了。</strong>  </p>
<p><strong>第二步。安装cygwin</strong>    </p>
<ul>
<li>解压下载到的压缩包（比如解压到C盘，解压出来的东西包括：<strong>cygwin_packages</strong>文件夹、s<strong>etup.exe</strong>、安装说明.txt），记得路径中不要带中<br>文，最好也不要带空格。</li>
<li>运行 <strong>Setup.exe</strong> 安装程序</li>
<li>选择 “<strong>Install from Local Directory</strong>“，然后点击 <strong>Next</strong> （下一步）。</li>
<li>接下来，指定根目录。也就是你想要安装 <strong>Cygwin</strong> 的位置(但不能是本压缩包解压出来的 <strong>cygwin_packages</strong> 文件夹)。如果你喜欢，可以是<strong>C:\Cygwin</strong>，注意要确定文件夹名种没有空格。然后点击 <strong>Next</strong> （下一步）</li>
<li>然后，指定 <strong>Local Package Directory</strong>，必须指定为 <strong>cygwin_packages</strong> 文件夹所在路径（且<strong>cygwin_packages</strong>下级目录必须是<strong>英文</strong>（这一步有这样一个注意点，路径一定要指到<strong>cygwin_packages</strong> ）<br>。假如跳出了一个警告对话框，<strong>点击yes</strong>（是）。</li>
<li><p>当安装程序显示出所有的包名时，点击上方第一个的 “<strong>All &lt;-&gt; Default</strong>“ 为 “<strong>All &lt;-&gt; Install</strong>“ (点击那个环形箭头符号)（这一步有比较长的进度<br>条）   </p>
</li>
<li><p>然后点击 <strong>Next</strong> （下一步），安装程序就会为你安装好 <strong>Kitchen</strong> 需要 <strong>Cygwin</strong> 提供的一切支持</p>
</li>
<li>最后，点击桌面上的 <strong>Cygwin</strong> 快捷方式以便为你创建 <strong>home</strong> 文件夹。（如果此步一闪而过注意检查上面的步骤）</li>
<li><strong>最后，开始使用厨房：</strong></li>
<li>完成上面的步骤后，将下载到厨房解压到<strong>C:\Cygwin\home\Administrator</strong>（如果是你设置了自己的登录名，那么<strong>Administrator</strong>就变成你自己的用户名就行了，同理如果你不是在C盘，做相应变化）<br>也就是说，解压完厨房，<strong>C:\Cygwin\home\Administrator</strong>目录下必有：<strong>original_update</strong>，<strong>scripts</strong>，<strong>tools</strong>，<strong>menu</strong>这几个厨房文件</li>
<li><p>点击桌面上的 <strong>Cygwin</strong> 快捷方式</p>
</li>
<li><p>执行命令：<strong>./menu</strong><br><strong>正式开始使用厨房定制ROM</strong><br>厨房很强大，可以支持很多<strong>ROM</strong>，不管是官方的还是民间的，这里我能力有限只能稍微介绍怎么提取并修改官方<strong>ROM</strong>，其他<strong>ROM</strong>大家可以自己摸索。</p>
</li>
</ul>
<p>1，把拷贝出来的<strong>rom.zip</strong>复制到U盘中，<br>通过U盘把提取的ZIP复制到虚拟机中。<br>2，打开zip文件，或者解压zip文件，把里面的boot.img和system.img拷贝到桌面的<br>“到original update的链接”文件夹中。<br>3，运行桌面的“到menu的链接”，点击在终端中运行。(这一步好像有时候不行，按菜单功能不能进入，如果不行的话，大家只能打开主文件夹，双击menu打开。或者在附件-终端中输入“./menu”打开厨房了)<br>4，根据屏幕提示：选择1，按回车，再按回车，在按1选择刚才拷入的boot.img和system.img，按回车后就开始分解img文件了。分解后提示查看ROM的一些信息，根据需要Y或者N，回车。<br>5，根据菜单上的功能按相应的数字键进入。并根据提示完成定制。配置完，在主菜单选择99按回车可以打包定制目录，自动生成ROM。文件夹在主目录的output文件夹中（菜单栏-位置-主文件夹）。按上面的方法创建output文件夹的快速链接，并放到桌面去。方便以后打开。<br>6，把zip拷贝到U盘。再拷贝到手机内存卡。然后接下来大家都懂得。或者直接把手机通过可移动磁盘接入到虚拟机中也可以。操作和U盘一样。<br>厨房菜单功能简单介绍：</p>
<h2 id="Main-Menu（主菜单）"><a href="#Main-Menu（主菜单）" class="headerlink" title="Main Menu（主菜单）"></a>Main Menu（主菜单）</h2><ul>
<li><ol>
<li>Set up working folder from ROM（从ROM文件导入到工作文件夹）</li>
</ol>
</li>
<li><ol>
<li>Add root permissions（加入ROOT权限）</li>
</ol>
</li>
<li><ol>
<li>Add BusyBox（加入BusyBox）</li>
</ol>
</li>
<li><ol>
<li>Disable boot screen sounds（禁止启动音乐）</li>
</ol>
</li>
<li><ol>
<li>Add wireless tethering（加入WIFI共享）</li>
</ol>
</li>
<li><ol>
<li>Zipalign all *.apk files to optimize RAM usage（对所有apk进行Zipalign，进行程序内存优化）</li>
</ol>
</li>
<li><ol>
<li>Change wipe status of ROM（刷机时清除机器数据和缓存，但不包括SD-ext分区）</li>
</ol>
</li>
<li><ol>
<li>Change name of ROM（更改ROM的名称）</li>
</ol>
</li>
<li><ol>
<li>Check update-script for errors（检查update-script升级脚本是否有错误）</li>
</ol>
</li>
<li><ol>
<li>Show working folder information（显示工作目录下rom的信息）<br>Advanced Options（增强定制选项）</li>
</ol>
</li>
<li>11 - Deodex files in your ROM （Deodex ROM中的文件，就是把system/app下的APK和ODEX合并为一个apk文件，以便进行更新系统软件）</li>
<li>12 - Add task killer tweak for speed (stock ROM only)（加入Android内存优化用以加快速度，只适用于官方ROM）</li>
<li>13 - Add /data/app functionality（加入自定义可卸载程序存放目录，放在这里面的程序刷机后可以卸载，刷完格式化手机也会丢失）</li>
<li>14 - Add Nano text editor + sysro/sysrw（加入Nano文本编辑器，System目录的只读和读写转换）</li>
<li>15 - Add Bash (command shell)（加入Shell命令集）</li>
<li>16 - Add Apps2SD（加入Apps2SD功能，就是A2SD+之类的）</li>
<li>17 - Add /etc/init.d scripts support (busybox run-parts)（加入对/etc/init.d目录下脚本运行的支持）</li>
<li>18 - Add custom boot animation functionality（加入自定义开机动画的支持）</li>
<li>19 - Porting tools (experimental)（移植工具，仅测试）</li>
<li>20 - Unpack or re-pack a boot.img（打包或解包boot.img）</li>
<li>21 - Unpack data.img （分解data.img）</li>
<li>22 - Sign APK file(s)（签名apk安装包）</li>
<li>23 - Convert update-script or updater-script（转换update-script 或者updater-script）</li>
<li>24 - Run plugin scripts（运行插件脚本之类的）<br>Build ROM from working folder（将工作目录下的ROM打包，打包完就可以刷机了。）</li>
<li>About/Update kitchen（厨房的升级，关于）</li>
<li>X. Exit（退出）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-厨房简介及环境配置&quot;&gt;&lt;a href=&quot;#一-厨房简介及环境配置&quot; class=&quot;headerlink&quot; title=&quot;一.厨房简介及环境配置&quot;&gt;&lt;/a&gt;一.厨房简介及环境配置&lt;/h2&gt;&lt;h3 id=&quot;1-厨房简介&quot;&gt;&lt;a href=&quot;#1-厨房简介&quot; cla
    
    </summary>
    
      <category term="以前" scheme="http://91fz.org/categories/%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="ROM修改" scheme="http://91fz.org/tags/ROM%E4%BF%AE%E6%94%B9/"/>
    
      <category term="美化ROM" scheme="http://91fz.org/tags/%E7%BE%8E%E5%8C%96ROM/"/>
    
  </entry>
  
  <entry>
    <title>让国产山寨手机死机黑屏之imy</title>
    <link href="http://91fz.org/2011/11/15/imy/"/>
    <id>http://91fz.org/2011/11/15/imy/</id>
    <published>2011-11-14T16:00:00.000Z</published>
    <updated>2017-07-01T16:16:01.155Z</updated>
    
    <content type="html"><![CDATA[<p>IMY铃声是一段铃声代码文件，具有占有空间小、容易编辑等特点。中国移动规定其为通用彩信文件格式之一,可以用短信进行收发（当然不花流量咯！）。IMY标准非常灵活，音域跨了9个8度，24种不同音长；还可以加入振动、屏幕背光及来电灯亮灭的效果，给人以更加美妙神奇的音乐体验。</p>
<h2 id="怎样看你的手机是否支持IMY铃声？"><a href="#怎样看你的手机是否支持IMY铃声？" class="headerlink" title="　　怎样看你的手机是否支持IMY铃声？"></a>　　怎样看你的手机是否支持IMY铃声？</h2><p>　　短信编辑界面，选项——插入对象——我的铃声/预设铃声。（IMY铃声文件在短信中会以音符的图标显示。）<br>　　若能进行上述操作，则恭喜你，你的手机支持IMY;若“我的铃声”为空白，则你的手机闪存（人们习惯上将其错叫成“手机内存”）里的“audio”文件夹里没有IMY铃声。)
　　</p>
<h2 id="imy可传播手机病毒吗？"><a href="#imy可传播手机病毒吗？" class="headerlink" title="imy可传播手机病毒吗？"></a>imy可传播手机病毒吗？</h2><p>　　2008年11月以来，很多人收到了一些“黑屏短信”、“死机短信”、“狂振、狂闪短信”，这些短信是怎么做到的呢？又是不是病毒呢？<br>　　了解了IMY的本质，就不难回答上面的问题（请看上文加粗的文字）。这也正是“山寨机”容易中招的原因。<br>　　那些短信中包含有一些恶作剧的IMY铃声文件。以黑屏短信为例，这个IMY铃声文件不含声音代码，而只含有关闭背光、来电灯以及振动的命令（下面将会进一步详解），让人误认为是死机。笔者亲自试过，这个文件只会让手机黑屏73秒，并非真死，并且对手机无害。<br>　　IMY铃声调用的命令仅仅是声音指令、振动开启及关闭指令、屏幕背光和来电灯亮灭指令。所以并非病毒。虽不是病毒，但手机狂振、狂闪却应该是对手机有伤害的。<br>　　那么，如何删除带有这种恶作剧IMY铃声文件的短信呢？<br>　　　——调成静音模式，然后删除。原因是静音模式时，IMY铃声就不会播放，其中的恶作剧就不会得逞。呵呵~<br>　　还是强烈倡议大家“和平使用”IMY铃声。过犹不及嘛，恶作剧也应有个度。</p>
<h2 id="IMY铃声恶作剧例子"><a href="#IMY铃声恶作剧例子" class="headerlink" title="IMY铃声恶作剧例子"></a>IMY铃声恶作剧例子</h2><p>　　黑屏：<br>　<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　BEGIN:IMELODY</div><div class="line">　　BEAT:1200</div><div class="line">　　MELODY:(ledoffbackoffvibeoffr5ledoffbackoffvibeoffr5@600)</div><div class="line">　　END:IMELODY</div></pre></td></tr></table></figure></p>
<p>　　狂震：<br>　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">　　BEGIN:IMELODY</div><div class="line">　　VERSION:1.2</div><div class="line">　　FORMAT:CLASS1.0</div><div class="line">　　BEAT:100</div><div class="line">　　MELODY:(ledoffledonbackoffbackonvibeon@300)</div><div class="line">　　END:IMELODY</div></pre></td></tr></table></figure></p>
<p>　　振铃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　BEGIN:IMELODY</div><div class="line">　　VERSION:1.2</div><div class="line">　　FORMAT:CLASS1.0</div><div class="line">　　BEAT:200</div><div class="line">　　MELODY:(ledoffbackoffvibeonr5vibeoffledonbackonr5@200)</div><div class="line">　　END:IMELODY</div></pre></td></tr></table></figure></p>
<h2 id="IMY铃声代码详解"><a href="#IMY铃声代码详解" class="headerlink" title="IMY铃声代码详解"></a>IMY铃声代码详解</h2><p>　　其实IMY铃声文件本无罪，所以大家不要被恶作剧吓到。<br>　　下面通过《生日快乐歌》的代码，来详细了解一下IMY代码格式。（两排#号间为要存储为<em>.imy文件中的内容；引号及其中间内容为代码解释，实际代码中没有；“MELODY旋律字符串”中的空格也是为了大家看的更明白而加上的）<br>　　<br>　　<em>*注意：代码一律用英文半角字符.</em></em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">　　BEGIN:IMELODY</div><div class="line">　　VERSION:1.2　“版本号”</div><div class="line">　　FORMAT:CLASS1.0　“格式编号。取值CLASS1.0或CLASS2.0，前者居多”</div><div class="line">　　NAME:HAPPY BIRTHDAY　“铃声名。可缺省”</div><div class="line">　　COMPOSER:MTK(13)　“演奏乐器。可缺省”</div><div class="line">　　BEAT:165　“节奏。取值从25到900bpm（拍/分钟），越大节奏越快，缺省值120”</div><div class="line">　　STYLE:S0　“风格。取值为S0；S1；S2；缺省值S0”</div><div class="line">　　VOLUME:V10　“音量。取值V0到V15。V0为静音，缺省值V7”</div><div class="line">　　MELODY:(*3a2 V+ a2 #f2 d2 #c2 *3b1 g2 #f2 d2 V- e2 vibeon ledon backoff d1 vibeoff ledoff backon @2)　“旋律字符串”</div><div class="line">　　END:IMELODY</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">“风格STYLE”中</div><div class="line">　　S0：普通。每音符间有暂停，音符与暂停时间比为20:1</div><div class="line">　　S1：持续。每音符间无暂停</div><div class="line">　　S2：断奏。音符与暂停时间比为1:1</div><div class="line">“旋律字符串MELODY”中的特效命令</div><div class="line">　　“vibeon”、“vibeoff” 分别为振动开启，停止命令；</div><div class="line">　　“ledoff”、“ledon” 分别为来电灯关闭、开启命令；</div><div class="line">　　“backoff”、“backon” 分别为屏幕背光关闭、开启命令；</div><div class="line">　　&quot;(&quot;+&lt;melody&gt;+&quot;@n)&quot; 为重复特效,n取值0到无穷（0为无限重复）</div><div class="line">“旋律字符串MELODY”中的音符格式</div><div class="line">　　&lt;音阶&gt;&lt;升降调&gt;&lt;具体唱名&gt;&lt;音长&gt;&lt;延时符&gt;</div><div class="line">　　&lt;音阶&gt;：取值 “*0”、“*2”、… “*8”；(a=55Hz) | (a=110Hz) | … | (a=14080 Hz) 缺省&quot;*4&quot;，代表标准音（小字一组a音为880Hz）。</div><div class="line">　　&lt;升降调&gt;：“#”代表升半音，d、g、a、c、f前可加“#”；</div><div class="line">　　“&amp;”代表降半音，d、g、a、b、e前可加“&amp;”。</div><div class="line">　　&lt;具体唱名&gt;：c、d、e、f、g、a、b。</div><div class="line">　　&lt;音长&gt;：数值&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot;，分别为全音符、半音符、1/4音符...1/32音符。</div><div class="line">　　&lt;延时符&gt;：“.” | “:”| “;” ;延时符，1.5倍、1.75倍与2/3倍。</div><div class="line">“旋律字符串MELODY”中的休止符</div><div class="line">　　r0，r1，r2，r3，r4，r5；停顿时长分别为全音符、半音符、1/4音符...1/32音符 。</div><div class="line">　　其后同样可加延时符，如“r3.”。</div><div class="line">“旋律字符串MELODY”中音量控制</div><div class="line">　　V+，V-。</div></pre></td></tr></table></figure>
<h2 id="怎样获得imy铃声文件？"><a href="#怎样获得imy铃声文件？" class="headerlink" title="怎样获得imy铃声文件？"></a>怎样获得imy铃声文件？</h2><p>　   　可以DIY。网上有一些制作imy铃声的软件，可以用他们来DIY也可以用一些软件来将其他格式的音乐转换成imy格式。还可以在网上找一些代码的文本，复制到记事本里，把文件后缀”.txt”改成”.imy”，保存到手机闪存的“audio”文件夹里即可。</p>
<p>　　<br>  　<strong>OK，现在就用浪漫十足的IMY铃声来扮炫你的生活吧！！！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IMY铃声是一段铃声代码文件，具有占有空间小、容易编辑等特点。中国移动规定其为通用彩信文件格式之一,可以用短信进行收发（当然不花流量咯！）。IMY标准非常灵活，音域跨了9个8度，24种不同音长；还可以加入振动、屏幕背光及来电灯亮灭的效果，给人以更加美妙神奇的音乐体验。&lt;/p
    
    </summary>
    
      <category term="以前" scheme="http://91fz.org/categories/%E4%BB%A5%E5%89%8D/"/>
    
    
      <category term="moblie" scheme="http://91fz.org/tags/moblie/"/>
    
      <category term="死机短信" scheme="http://91fz.org/tags/%E6%AD%BB%E6%9C%BA%E7%9F%AD%E4%BF%A1/"/>
    
      <category term="狂振" scheme="http://91fz.org/tags/%E7%8B%82%E6%8C%AF/"/>
    
      <category term="狂闪短信" scheme="http://91fz.org/tags/%E7%8B%82%E9%97%AA%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
</feed>
