<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/favicon.ico"><meta name="robots" content="all"><meta name="author" content="fengzijk"><meta name="keywords" content="中间件,微服务,服务治理,springcloud, java框架,calf-cloud,go学习路线,java spring,  java编程指南, vue开发,vue教程,java,java数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><script src="https://hm.baidu.com/hm.js?7469927f8d68f752c147cd9df8cd19d3"></script><title>fengzijk的博客</title><meta name="description" content="fengzijk的博客">
    <link rel="modulepreload" href="/assets/app.c62b2955.js"><link rel="modulepreload" href="/assets/关于RPC的总结.html.9ccb2018.js"><link rel="modulepreload" href="/assets/关于RPC的总结.html.037d7c7e.js"><link rel="prefetch" href="/assets/aboat-me.html.7265baab.js"><link rel="prefetch" href="/assets/index.html.c038c7ec.js"><link rel="prefetch" href="/assets/centos-redis-源码安装配置.html.f1f14ff9.js"><link rel="prefetch" href="/assets/centos下yum安装卸载mysql笔记.html.33461b47.js"><link rel="prefetch" href="/assets/Centos安装JDK.html.6c0752bd.js"><link rel="prefetch" href="/assets/ICE入门到精通(一).html.0f6a85e8.js"><link rel="prefetch" href="/assets/java8.html.77563c06.js"><link rel="prefetch" href="/assets/JAVA实现类似百度文库在线浏览.html.7fe84d87.js"><link rel="prefetch" href="/assets/Kotlin初探集成springMvc.html.7c9536b6.js"><link rel="prefetch" href="/assets/MongoDB地理位置索引的实现原理.html.d1e0bb0d.js"><link rel="prefetch" href="/assets/QQ实用技术.html.ba418346.js"><link rel="prefetch" href="/assets/index.html.1794e816.js"><link rel="prefetch" href="/assets/ROM修改之厨房简介及环境配置.html.1b1502c8.js"><link rel="prefetch" href="/assets/服务治理框架之DUBBO.html.f30b8060.js"><link rel="prefetch" href="/assets/自己刷机的一些感触和经验.html.af298b9a.js"><link rel="prefetch" href="/assets/让国产山寨手机死机黑屏之imy.html.ca41c909.js"><link rel="prefetch" href="/assets/谈谈服务治理与微服务.html.a28c8290.js"><link rel="prefetch" href="/assets/阿里云部署Web环境(LAMP).html.2fd4fe4c.js"><link rel="prefetch" href="/assets/404.html.93146c89.js"><link rel="prefetch" href="/assets/aboat-me.html.90600189.js"><link rel="prefetch" href="/assets/index.html.bf3f4e88.js"><link rel="prefetch" href="/assets/centos-redis-源码安装配置.html.aa4a0e51.js"><link rel="prefetch" href="/assets/centos下yum安装卸载mysql笔记.html.8f8a6042.js"><link rel="prefetch" href="/assets/Centos安装JDK.html.3e4cc809.js"><link rel="prefetch" href="/assets/ICE入门到精通(一).html.84ecdd3d.js"><link rel="prefetch" href="/assets/java8.html.21e91c1a.js"><link rel="prefetch" href="/assets/JAVA实现类似百度文库在线浏览.html.6a33f2e3.js"><link rel="prefetch" href="/assets/Kotlin初探集成springMvc.html.00bb4e8d.js"><link rel="prefetch" href="/assets/MongoDB地理位置索引的实现原理.html.6848c28a.js"><link rel="prefetch" href="/assets/QQ实用技术.html.5045b312.js"><link rel="prefetch" href="/assets/index.html.bd8b4e91.js"><link rel="prefetch" href="/assets/ROM修改之厨房简介及环境配置.html.0fdebcce.js"><link rel="prefetch" href="/assets/服务治理框架之DUBBO.html.cca6060d.js"><link rel="prefetch" href="/assets/自己刷机的一些感触和经验.html.cb116888.js"><link rel="prefetch" href="/assets/让国产山寨手机死机黑屏之imy.html.a715fdd1.js"><link rel="prefetch" href="/assets/谈谈服务治理与微服务.html.cd6136ae.js"><link rel="prefetch" href="/assets/阿里云部署Web环境(LAMP).html.bf2ce772.js"><link rel="prefetch" href="/assets/404.html.11e2794b.js"><link rel="prefetch" href="/assets/404.8d3e3ac9.js"><link rel="prefetch" href="/assets/Layout.53613210.js">
    <link rel="stylesheet" href="/assets/style.78d99c6f.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">fengzijk的博客</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JAVA"><span class="title">JAVA</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JAVA"><span class="title">JAVA</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/" class="router-link-active" aria-label="java基础"><!--[--><!--]--> java基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="mybatis"><span class="title">mybatis</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="mybatis"><span class="title">mybatis</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/mybatis-plus/" class="" aria-label="mybatis-plus"><!--[--><!--]--> mybatis-plus <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/tk-mapper/" class="" aria-label="tk-mapper"><!--[--><!--]--> tk-mapper <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="spring-cloud"><span class="title">spring-cloud</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="spring-cloud"><span class="title">spring-cloud</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/" class="router-link-active" aria-label="spring-cloud"><!--[--><!--]--> spring-cloud <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud-alibaba/" class="" aria-label="spring-cloud-alibaba"><!--[--><!--]--> spring-cloud-alibaba <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="杂记"><span class="title">杂记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="杂记"><span class="title">杂记</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>老博客</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/old-blog/" class="router-link-active" aria-label="胡侃"><!--[--><!--]--> 胡侃 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/aboat-me.md" class="" aria-label="关于我"><!--[--><!--]--> 关于我 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gitlab.com/foo/bar" rel="noopener noreferrer" target="_blank" aria-label="GitLab"><!--[--><!--]--> GitLab <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JAVA"><span class="title">JAVA</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JAVA"><span class="title">JAVA</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/" class="router-link-active" aria-label="java基础"><!--[--><!--]--> java基础 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="mybatis"><span class="title">mybatis</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="mybatis"><span class="title">mybatis</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/mybatis-plus/" class="" aria-label="mybatis-plus"><!--[--><!--]--> mybatis-plus <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/tk-mapper/" class="" aria-label="tk-mapper"><!--[--><!--]--> tk-mapper <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="spring-cloud"><span class="title">spring-cloud</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="spring-cloud"><span class="title">spring-cloud</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/" class="router-link-active" aria-label="spring-cloud"><!--[--><!--]--> spring-cloud <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/spring-cloud-alibaba/" class="" aria-label="spring-cloud-alibaba"><!--[--><!--]--> spring-cloud-alibaba <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="杂记"><span class="title">杂记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="杂记"><span class="title">杂记</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>老博客</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/old-blog/" class="router-link-active" aria-label="胡侃"><!--[--><!--]--> 胡侃 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/aboat-me.md" class="" aria-label="关于我"><!--[--><!--]--> 关于我 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gitlab.com/foo/bar" rel="noopener noreferrer" target="_blank" aria-label="GitLab"><!--[--><!--]--> GitLab <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#关于rpc的总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于RPC的总结"><!--[--><!--]--> 关于RPC的总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#什么是rpc" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是RPC"><!--[--><!--]--> 什么是RPC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#rpc起源" class="router-link-active router-link-exact-active sidebar-item" aria-label="RPC起源"><!--[--><!--]--> RPC起源 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#rpc-结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="RPC 结构"><!--[--><!--]--> RPC 结构 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#rpc-组件职责" class="router-link-active router-link-exact-active sidebar-item" aria-label="RPC 组件职责"><!--[--><!--]--> RPC 组件职责 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#rpc-实现分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="RPC 实现分析"><!--[--><!--]--> RPC 实现分析 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#导入远程接口与客户端代理" class="router-link-active router-link-exact-active sidebar-item" aria-label="导入远程接口与客户端代理"><!--[--><!--]--> 导入远程接口与客户端代理 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#调用编码" class="router-link-active router-link-exact-active sidebar-item" aria-label="调用编码"><!--[--><!--]--> 调用编码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#返回编码" class="router-link-active router-link-exact-active sidebar-item" aria-label="返回编码"><!--[--><!--]--> 返回编码 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/old-blog/%E5%85%B3%E4%BA%8ERPC%E7%9A%84%E6%80%BB%E7%BB%93.html#常见的-rpc-框架-double-grpc-motan-thrift-avro-性能对比" class="router-link-active router-link-exact-active sidebar-item" aria-label="常见的 rpc 框架 double grpc motan thrift avro 性能对比"><!--[--><!--]--> 常见的 rpc 框架 double grpc motan thrift avro 性能对比 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="关于rpc的总结" tabindex="-1"><a class="header-anchor" href="#关于rpc的总结" aria-hidden="true">#</a> 关于RPC的总结</h2><p>发表于 2015-08-20</p><p>相信大家的都对RPC框架很熟悉，但有人经常混淆 所以写一篇文章简单介绍下，写的不好 欢迎底下评论留言</p><h2 id="什么是rpc" tabindex="-1"><a class="header-anchor" href="#什么是rpc" aria-hidden="true">#</a> 什么是RPC</h2><p>它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<strong>RPC</strong>协议假定某些传输协议的存在，如<strong>TCP</strong>或<strong>UDP</strong>，为通信程序之间携带信息数据。 RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><p>通俗点就是它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。</p><h2 id="rpc起源" tabindex="-1"><a class="header-anchor" href="#rpc起源" aria-hidden="true">#</a> RPC起源</h2><p>RPC 这个概念术语在上世纪 80 年代由 <strong>Bruce</strong> <strong>Jay</strong> <strong>Nelson</strong> 提出。这里我们追溯下当初开发 <strong>RPC</strong> 的原动机是什么？在 <strong>Nelson</strong> 的论文 “<strong>Implementing Remote Procedure Calls</strong>“ 中他提到了几点：</p><ul><li><p>简单：RPC 概念的语义十分清晰和简单，这样建立分布式计算就更容易。</p></li><li><p>高效：过程调用看起来十分简单而且高效。</p></li><li><p>通用：在单机计算中过程往往是不同算法部分间最重要的通信机制</p><h3 id="rpc-结构" tabindex="-1"><a class="header-anchor" href="#rpc-结构" aria-hidden="true">#</a> RPC 结构</h3><p>Nelson</p><p>的论文中指出实现 RPC 的程序包括 5 个部分：</p></li><li><p><strong>User</strong></p></li><li><p><strong>User-stub</strong></p></li><li><p><strong>RPCRuntime</strong></p></li><li><p><strong>Server-stub</strong></p></li><li><p><strong>Server</strong></p></li></ul><p>这 5 个部分的关系如下图所示 <a href="/images/rpc/01.png"><img src="/images/rpc/01.png" alt="image"></a></p><p><strong>RPC</strong> 服务方通过 <strong>RpcServer</strong> 去导出（<strong>export</strong>）远程接口方法，而客户方通过 <strong>RpcClient</strong> 去引入（<strong>import</strong>）远程接口方法。 客户方像调用本地方法一样去调用远程接口方法，<strong>RPC</strong> 框架提供接口的代理实现，实际的调用将委托给代理 <strong>RpcProxy</strong> 。 代理封装调用信息并将调用转交给 <strong>RpcInvoker</strong> 去实际执行。 在客户端的 <strong>RpcInvoker</strong> 通过连接器 <strong>RpcConnector</strong> 去维持与服务端的通道 RpcChannel， 并使用 <strong>RpcProtocol</strong> 执行协议编码（<strong>encode</strong>）并将编码后的请求消息通过通道发送给服务方。</p><p>RPC 服务端接收器 <strong>RpcAcceptor</strong> 接收客户端的调用请求，同样使用 RpcProtocol 执行协议解码（<strong>decode</strong>）。 解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果</p><p>这里 <strong>user</strong> 就是 <strong>client</strong> 端，当 <strong>user</strong> 想发起一个远程调用时，它实际是通过本地调用 <strong>user-stub</strong>。<strong>user-stub</strong> 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 <strong>RPCRuntime</strong> 实例传输到远端的实例。远端 <strong>RPCRuntime</strong> 实例收到请求后交给 <strong>server-stub</strong> 进行解码后发起本地端调用，调用结果再返回给 <strong>user</strong> 端。</p><h2 id="rpc-组件职责" tabindex="-1"><a class="header-anchor" href="#rpc-组件职责" aria-hidden="true">#</a> RPC 组件职责</h2><p>上面我们进一步拆解了 RPC 实现结构的各个组件组成部分，下面我们详细说明下每个组件的职责划分。</p><ul><li><strong>RpcServer</strong> 负责导出（<strong>export</strong>）远程接口</li><li>RpcClient 负责导入（<strong>import</strong>）远程接口的代理实现</li><li>RpcProxy 远程接口的代理实现</li><li><strong>RpcInvoker</strong> 客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回 服务方实现：负责调用服务端接口的具体实现并返回调用结果</li><li><strong>RpcProtocol</strong> 负责协议编/解码</li><li><strong>RpcConnector</strong> 负责维持客户方和服务方的连接通道和发送数据到服务方</li><li><strong>RpcAcceptor</strong> 负责接收客户方请求并返回请求结果</li><li><strong>RpcProcessor</strong> 负责在服务方控制调用过程，包括管理调用线程池、超时时间等</li><li><strong>RpcChannel</strong> 数据传输通道</li></ul><h2 id="rpc-实现分析" tabindex="-1"><a class="header-anchor" href="#rpc-实现分析" aria-hidden="true">#</a> RPC 实现分析</h2><p>在进一步拆解了组件并划分了职责之后，这里以在 <strong>java</strong> 平台实现该 <strong>RPC</strong> 框架概念模型为例，详细分析下实现中需要考虑的因素。 导出远程接口 导出远程接口的意思是指只有导出的接口可以供远程调用，而未导出的接口则不能。 在 <strong>java</strong> 中导出接口的代码片段可能如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>DemoService demo   <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
RpcServer   server <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
server.export<span class="token punctuation">(</span>DemoService.class, demo, options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们可以导出整个接口，也可以更细粒度一点只导出接口中的某些方法，如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>// 只导出 DemoService 中签名为 hi<span class="token punctuation">(</span>String s<span class="token punctuation">)</span> 的方法
server.export<span class="token punctuation">(</span>DemoService.class, demo,<span class="token string">&quot;hi&quot;</span>,newClass<span class="token operator">&lt;</span>?<span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> String.class<span class="token punctuation">}</span>, options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>Java</strong> 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？ 这个本地调用的语义是通过 <strong>jvm</strong> 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。 如果前面 <strong>DemoService</strong> 接口有2个实现，那么在导出接口时就需要特殊标记不同的实现，如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>DemoService demo   <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
DemoService demo2  <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
RpcServer   server <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
server.export<span class="token punctuation">(</span>DemoService.class, demo, options<span class="token punctuation">)</span><span class="token punctuation">;</span>
server.export<span class="token punctuation">(</span><span class="token string">&quot;demo2&quot;</span>, DemoService.class, demo2, options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="导入远程接口与客户端代理" tabindex="-1"><a class="header-anchor" href="#导入远程接口与客户端代理" aria-hidden="true">#</a> <strong>导入远程接口与客户端代理</strong></h3><p>导入相对于导出远程接口，客户端代码为了能够发起调用必须要获得远程接口的方法或过程定义。 目前，大部分跨语言平台 <strong>RPC</strong> 框架采用根据 <strong>IDL</strong> 定义通过 <strong>code generator</strong> 去生成 <strong>stub</strong> 代码， 这种方式下实际导入的过程就是通过代码生成器在编译期完成的。 我所使用过的一些跨语言平台 <strong>RPC</strong> 框架如 <strong>CORBAR</strong>、<strong>WebService</strong>、<strong>ZEROC-ICE</strong>、<strong>Thrift</strong> 均是此类方式。</p><p>代码生成的方式对跨语言平台 <strong>RPC</strong> 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。 在 <strong>java</strong> 中导入接口的代码片段如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>RpcClient client <span class="token operator">=</span>new<span class="token punctuation">..</span>.<span class="token punctuation">;</span>
DemoService demo <span class="token operator">=</span> client.refer<span class="token punctuation">(</span>DemoService.class<span class="token punctuation">)</span><span class="token punctuation">;</span>
demo.hi<span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 java 中 <strong>import</strong> 是关键字，所以代码片段中我们用 <strong>refer</strong> 来表达导入接口的意思。 这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。 <strong>java</strong> 里至少提供了两种技术来提供动态代码生成，一种是 <strong>jdk</strong> 动态代理，另外一种是字节码生成。 动态代理相比字节码生成使用起来更方便，但动态代理方式在性能上是要逊色于直接的字节码生成的，而字节码生成在代码可读性上要差很多。 两者权衡起来，牺牲一些性能来获得代码可读性和可维护性显得更重要。 协议编解码 客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。 出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。 我们先看下需要编码些什么信息：</p><h3 id="调用编码" tabindex="-1"><a class="header-anchor" href="#调用编码" aria-hidden="true">#</a> 调用编码</h3><ul><li><p>接口方法 包括接口名、方法名</p></li><li><p>方法参数 包括参数类型、参数值</p></li><li><p>调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等</p><h3 id="返回编码" tabindex="-1"><a class="header-anchor" href="#返回编码" aria-hidden="true">#</a> 返回编码</h3></li><li><p>返回结果 接口方法中定义的返回值</p></li><li><p>返回码 异常返回码</p></li><li><p>返回异常信息 调用异常信息 除了以上这些必须的调用信息，我们可能还需要一些元信息以方便程序编解码以及未来可能的扩展。 这样我们的编码消息里面就分成了两部分，一部分是元信息、另一部分是调用的必要信息。 如果设计一种 RPC 协议消息的话，元信息我们把它放在协议消息头中，而必要信息放在协议消息体中。 下面给出一种概念上的 <strong>RPC</strong> 协议消息设计格式： <a href="/images/rpc/02.png"><img src="/images/rpc/02.png" alt="image"></a></p></li><li><p><strong>magic</strong> : 协议魔数，为解码设计</p></li><li><p><strong>header size</strong>: 协议头长度，为扩展设计</p></li><li><p><strong>version</strong> : 协议版本，为兼容设计</p></li><li><p><strong>st</strong> : 消息体序列化类型</p></li><li><p><strong>hb</strong> : 心跳消息标记，为长连接传输层心跳设计</p></li><li><p><strong>ow</strong> : 单向消息标记，</p></li><li><p><strong>rp</strong> : 响应消息标记，不置位默认是请求消息</p></li><li><p><strong>status</strong> <strong>code</strong>: 响应消息状态码</p></li><li><p><strong>reserved</strong> : 为字节对齐保留</p></li><li><p><strong>message</strong> <strong>id</strong> : 消息 id</p></li><li><p><strong>body</strong> <strong>size</strong> : 消息体长度</p></li></ul><h4 id="消息体" tabindex="-1"><a class="header-anchor" href="#消息体" aria-hidden="true">#</a> <strong>消息体</strong></h4><p>采用序列化编码，常见有以下格式</p><ul><li><p><strong>xml</strong> : 如 <strong>webservie</strong> <strong>SOAP</strong></p></li><li><p><strong>json</strong> : 如 <strong>JSON-RPC</strong></p></li><li><p><strong>binary</strong>: 如 <strong>thrift</strong>; <strong>hession</strong>; <strong>kryo</strong> 等 格式确定后编解码就简单了，由于头长度一定所以我们比较关心的就是消息体的序列化方式。 序列化我们关心三个方面：</p><p><strong>序列化和反序列化的效率，越快越好。</strong></p></li></ul><p><strong>序列化后的字节长度，越小越好</strong></p><p><strong>序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。</strong> 上面这三点有时是鱼与熊掌不可兼得，这里面涉及到具体的序列化库实现细节，就不在本文进一步展开分析了。</p><h4 id="传输服务" tabindex="-1"><a class="header-anchor" href="#传输服务" aria-hidden="true">#</a> 传输服务</h4><p>协议编码之后，自然就是需要将编码后的 <strong>RPC</strong> 请求消息传输到服务方，服务方执行后返回结果消息或确认消息给客户方。 <strong>RPC</strong> 的应用场景实质是一种可靠的请求应答消息流，和 <strong>HTTP</strong> 类似。 因此选择长连接方式的 <strong>TCP</strong> 协议会更高效，与 <strong>HTTP</strong> 不同的是在协议层面我们定义了每个消息的唯一 <strong>id</strong>，因此可以更容易的复用连接。</p><p>既然使用长连接，那么第一个问题是到底 <strong>client</strong> 和 <strong>server</strong> 之间需要多少根连接？ 实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。 单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区， 因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。 所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升， 反而会增加连接管理的开销。</p><p>连接是由 client 端发起建立并维持。 如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。 如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。 为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。 心跳消息是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位， 就是用来标记心跳消息的，它对业务应用透明。</p><h4 id="执行调用" tabindex="-1"><a class="header-anchor" href="#执行调用" aria-hidden="true">#</a> 执行调用</h4><p>client stub 所做的事情仅仅是编码消息并传输给服务方，而真正调用过程发生在服务方。 server stub 从前文的结构拆解中我们细分了 <strong>RpcProcessor</strong> 和 <strong>RpcInvoker</strong> 两个组件， 一个负责控制调用过程，一个负责真正调用。 这里我们还是以 <strong>java</strong> 中实现这两个组件为例来分析下它们到底需要做什么？</p><p>java 中实现代码的动态接口调用目前一般通过反射调用。 除了原生的 jdk 自带的反射，一些第三方库也提供了性能更优的反射调用， 因此 <strong>RpcInvoker</strong> 就是封装了反射调用的实现细节。</p><p>调用过程的控制需要考虑哪些因素，<strong>RpcProcessor</strong> 需要提供什么样地调用控制服务呢？ 下面提出几点以启发思考：</p><h4 id="效率提升" tabindex="-1"><a class="header-anchor" href="#效率提升" aria-hidden="true">#</a> 效率提升</h4><p>每个请求应该尽快被执行，因此我们不能每请求来再创建线程去执行，需要提供线程池服务。</p><h4 id="资源隔离" tabindex="-1"><a class="header-anchor" href="#资源隔离" aria-hidden="true">#</a> 资源隔离</h4><p>当我们导出多个远程接口时，如何避免单一接口调用占据所有线程资源，而引发其他接口执行阻塞。</p><h4 id="超时控制" tabindex="-1"><a class="header-anchor" href="#超时控制" aria-hidden="true">#</a> 超时控制</h4><p>当某个接口执行缓慢，而 <strong>client</strong> 端已经超时放弃等待后，<strong>server</strong> 端的线程继续执行此时显得毫无意义。 RPC 异常处理 无论 RPC 怎样努力把远程调用伪装的像本地调用，但它们依然有很大的不同点，而且有一些异常情况是在本地调用时绝对不会碰到的。 在说异常处理之前，我们先比较下本地调用和 <strong>RPC</strong> 调用的一些差异：</p><p>本地调用一定会执行，而远程调用则不一定，调用消息可能因为网络原因并未发送到服务方。 本地调用只会抛出接口声明的异常，而远程调用还会跑出 <strong>RPC</strong> 框架运行时的其他异常。 本地调用和远程调用的性能可能差距很大，这取决于 <strong>RPC</strong> 固有消耗所占的比重。 正是这些区别决定了使用 <strong>RPC</strong> 时需要更多考量。 当调用远程接口抛出异常时，异常可能是一个业务异常， 也可能是 <strong>RPC</strong> 框架抛出的运行时异常（如：网络中断等）。 业务异常表明服务方已经执行了调用，可能因为某些原因导致未能正常执行， 而 <strong>RPC</strong> 运行时异常则有可能服务方根本没有执行，对调用方而言的异常处理策略自然需要区分。</p><p>由于 <strong>RPC</strong> 固有的消耗相对本地调用高出几个数量级，本地调用的固有消耗是纳秒级，而 RPC 的固有消耗是在毫秒级。 那么对于过于轻量的计算任务就并不合适导出远程接口由独立的进程提供服务， 只有花在计算任务上时间远远高于 RPC 的固有消耗才值得导出为远程接口提供服务。</p><h2 id="常见的-rpc-框架-double-grpc-motan-thrift-avro-性能对比" tabindex="-1"><a class="header-anchor" href="#常见的-rpc-框架-double-grpc-motan-thrift-avro-性能对比" aria-hidden="true">#</a> <strong>常见的 rpc 框架</strong> double grpc motan thrift avro <strong>性能对比</strong></h2><p><a href="/images/rpc/03.png"><img src="/images/rpc/03.png" alt="image"></a><a href="/images/rpc/04.png"><img src="/images/rpc/04.png" alt="image"></a><strong>下一篇讲一讲性能最好的 ZeroC——ICE</strong></p><!--]--></div><footer class="page-meta"><!----><!----><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.c62b2955.js" defer></script>
  </body>
</html>
